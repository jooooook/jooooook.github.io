<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++类中使用成员初始化列表和构造函数内赋值的区别</title>
    <link href="/2024/07/31/C-%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%85%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/31/C-%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%85%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类中使用成员初始化列表和构造函数内赋值的区别："><a href="#C-类中使用成员初始化列表和构造函数内赋值的区别：" class="headerlink" title="C++类中使用成员初始化列表和构造函数内赋值的区别："></a>C++类中使用成员初始化列表和构造函数内赋值的区别：</h1><p><strong>注意事项：初始化顺序应该是成员变量声明顺序</strong></p><p><strong>1、效率高：</strong></p><p>​<strong>成员初始化列表</strong>：构造并初始化；</p><p>​<strong>构造函数内赋值</strong>：构造后给个默认值（初始化），赋值</p><p><strong>2、有些时候必须使用初始化列表</strong></p><ul><li><p>当我们初始化<code>const</code>或引用类型成员变量，因为这些类型的成员在构造函数体执行前必须已经初始化</p><ul><li><strong><code>const</code> 成员</strong>：一旦被构造，<code>const</code> 成员的值就不能改变，因此它必须在构造过程中立即获得其最终值。如果没有在成员初始化列表中初始化，就没有其他机会对其进行赋值操作。</li><li><strong>引用成员</strong>：引用必须在定义时被初始化，并且一旦指向一个对象，就不能再指向另一个对象。因此，引用成员也必须在构造函数的成员初始化列表中被初始化。</li></ul></li><li><p>对于继承自其他类的对象，如果基类没有默认构造函数，必须在初始化列表中明确调用基类的某个构造函数。</p><ul><li>构造函数体内的代码是在所有成员（包括从基类继承的成员）已经被构造之后才会执行。因此，基类的构造函数必须在派生类任何成员初始化之前被调用，以保证基类的部分已经正确构造。这只能通过初始化列表来完成。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>当调用某个类实例的成员函数的时候，编译器怎么工作的</title>
    <link href="/2024/07/31/%E5%BD%93%E8%B0%83%E7%94%A8%E6%9F%90%E4%B8%AA%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <url>/2024/07/31/%E5%BD%93%E8%B0%83%E7%94%A8%E6%9F%90%E4%B8%AA%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="当调用某个类实例的成员函数的时候，编译器怎么工作的"><a href="#当调用某个类实例的成员函数的时候，编译器怎么工作的" class="headerlink" title="当调用某个类实例的成员函数的时候，编译器怎么工作的"></a>当调用某个类实例的成员函数的时候，编译器怎么工作的</h1><p>​当你调用一个对象的成员函数时，编译器在源代码编译阶段和运行时阶段的操作是不同的。以下是这个过程的详细解释：</p><p>编译阶段：</p><ol><li><strong>确定函数地址</strong>：编译器在编译阶段会为所有函数生成代码。每个类的成员函数都具有一个唯一的地址，在编译时确定。编译器将这个地址与函数名和其所在类的类型结合在一起，存储在一个表（<strong>符号表</strong>）中。</li><li><strong>类型检查</strong>：当你在源代码中调用一个对象的成员函数时，编译器会进行类型检查，确保你调用的函数在该类型的对象上确实存在，并且你使用的参数和返回类型也是正确的。</li></ol><p>运行时阶段：</p><ol><li><strong>找到函数地址</strong>：运行时根据编译阶段存储的信息，确定所要调用的函数地址。</li><li><strong>进行函数调用</strong>：在调用函数时，需要创建一个新的栈帧以存储函数的局部变量和参数。同时，编译器还会将特殊的 “this” 指针作为隐含参数传递给成员函数。”this” 指针指向的是正在调用该成员函数的对象实例。这样，成员函数就可以访问它所属的对象实例的成员变量了。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>static成员函数在调用时找到static成员变量的原理</title>
    <link href="/2024/07/31/static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%9C%A8%E8%B0%83%E7%94%A8%E6%97%B6%E6%89%BE%E5%88%B0static%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2024/07/31/static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%9C%A8%E8%B0%83%E7%94%A8%E6%97%B6%E6%89%BE%E5%88%B0static%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="static成员函数在调用时找到static成员变量的原理"><a href="#static成员函数在调用时找到static成员变量的原理" class="headerlink" title="static成员函数在调用时找到static成员变量的原理"></a>static成员函数在调用时找到static成员变量的原理</h1><p>​首先，所有的static成员变量（无论是在类中还是在函数中声明的）都被存储在程序的一个特殊区域，即静态存储区。每个static变量在内存中都有一个固定的地址。</p><p>​当你在static成员函数中使用这个static成员变量时，编译器会替换掉这个变量的引用，直接用这个变量在内存中的地址，这样就可以直接访问到这个变量。编译器在编译程序的时候，已经知道了所有static成员变量的内存地址，所以可以在编译时就直接将这些地址硬编码到生成的代码中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类中动态内存相关问题</title>
    <link href="/2024/07/31/%E7%B1%BB%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E7%B1%BB%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="类中动态内存相关问题"><a href="#类中动态内存相关问题" class="headerlink" title="类中动态内存相关问题"></a>类中动态内存相关问题</h1><p>不能在类声明中初始化静态成员变量，因为类声明只是描述了<strong>如何分配内存，但是不实际分配内存</strong>。但是如果静态成员是const或者枚举类型，则可以在类声明中初始化。</p><p>+++</p><p>问：为什么要有析构函数？</p><p>答：当删除类对象的时候可以释放掉对象本身所占用的内存，但是并不能自动释放属于对象成员指针所指向的内存。因此必须使用析构函数，在析构函数中使用delete来保证当对象过期时，可以释放掉由new所分配的内存。</p><p><strong>类创建中一些特殊的成员函数</strong></p><p>很多类中产生的问题都是由于特殊成员函数引起的，C++自动提供了下面这些成员函数：</p><ol><li>默认构造函数，如果没有定义构造函数</li><li>默认析构函数，如果没有定义</li><li>拷贝构造函数，如果没有定义</li><li>赋值运算符，如果没有定义</li><li>地址运算符，如果没有定义</li></ol><p>其中默认的拷贝构造函数和赋值运算符都是<strong>浅拷贝</strong>，如果类中有用new创建的动态变量，使用默认的会出现两次释放同一指针的问题，指针悬挂，程序乱码等，需要自己实现<strong>深拷贝的拷贝构造函数和赋值运算符</strong></p><p><strong>当在类中使用new时，应该注意一下几点：</strong></p><ol><li>如果在构造函数中用new初始化指针成员，那么在析构函数中应该使用delete</li><li>new和delete必须成对出现</li><li>应该定义一个复制构造函数，通过深拷贝将一个对象初始化为另一个对象</li><li>重载一个赋值运算符，通过深拷贝将一个对象复制给另一个对象。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类继承的问题</title>
    <link href="/2024/07/31/%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="基类与派生类特性"><a href="#基类与派生类特性" class="headerlink" title="基类与派生类特性"></a>基类与派生类特性</h2><p>创建派生类对象时，程序首先创建基类对象，也就是说<strong>基类对象应当在程序进入派生类构造函数之前被创建</strong>。c++使用成员初始化列表来完成。</p><p><strong>总结一下有关派生类构造函数的要点：</strong></p><ol><li>创建派生类对象前先创建基类对象</li><li>派生类构造函数应该通过成员初始化列表将基类信息传递给基类构造函数</li><li><strong>派生类构造函数应该初始化新增的数据成员</strong></li></ol><p>释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后执行基类的析构函数</p><hr><p><strong>派生类与基类之间有一些特殊的关系：</strong></p><ol><li><p>派生类对象可以使用基类的方法，条件是该方法不是私有的</p></li><li><p>基类指针可以在不进行显式类型转换的情况下指向派生类对象</p></li><li><p>基类引用可以在不进行显式类型转换的情况下引用派生类对象</p></li></ol><blockquote><p>注意事项：基类指针或引用确实可以指向派生类的对象，并且通过基类指针或引用，我们可以访问派生类中继承自基类的公有成员。但是如果派生类中重写了基类的函数那么，通过基类指针或引用调用该函数时，调用的具体版本（是基类的还是派生类的）取决于这个函数是否被声明为<code>virtual</code>。</p><ol><li>如果基类中的函数被声明为<code>virtual</code>，那么，当通过基类指针或引用调用该函数时，会调用对应的派生类版本（如果派生类中有重写该函数的话）。这被称作动态绑定或运行时多态性。</li><li>如果基类函数并未被声明为<code>virtual</code>，那么就没有动态绑定，只会调用基类版本不管指针或者引用是否指向派生类的实例。</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vector中的下标访问[]和at()</title>
    <link href="/2024/07/31/vector%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-%E5%92%8Cat/"/>
    <url>/2024/07/31/vector%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-%E5%92%8Cat/</url>
    
    <content type="html"><![CDATA[<h1 id="vector中的下标访问-和at-有何不同"><a href="#vector中的下标访问-和at-有何不同" class="headerlink" title="vector中的下标访问[]和at()有何不同"></a>vector中的下标访问[]和at()有何不同</h1><p><strong>下标运算符 <code>[]</code></strong></p><p>不进行边界检查，如果提供的索引超出范围，会导致未定义行为，导致程序崩溃</p><p><strong>成员函数 <code>at()</code></strong></p><p>访问元素之前会进行边界检查，如果提供的索引超出范围，会抛出 <code>std::out_of_range</code> 异常。</p><p>抛出异常可以使用try&#x2F;catch捕获和处理，try放可能异常的代码，catch捕获然后打印信息</p><p>相对于未定义行为，捕获异常更容易调试，定位问题</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>reserve和resize的区别</title>
    <link href="/2024/07/31/reserve%E5%92%8Cresize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/31/reserve%E5%92%8Cresize%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="reserve和resize的区别"><a href="#reserve和resize的区别" class="headerlink" title="reserve和resize的区别"></a>reserve和resize的区别</h1><p><code>reserve()</code>函数用于预先分配足够的内存，以容纳指定数量的元素，但不会实际创建或初始化这些元素。它的主要目的是避免在多次添加元素时频繁地重新分配内存，从而提高性能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 预分配内存，但不初始化元素</span><br></code></pre></td></tr></table></figure><ul><li>如果<code>n</code>大于当前的<code>vector</code>容量，<code>vector</code>将分配足够的内存，以至少容纳<code>n</code>个元素。</li><li>如果<code>n</code>小于或等于当前的容量，<code>vector</code>的容量不会改变。</li><li><code>vector</code>的大小（元素数量）不会改变。</li></ul><p><code>resize()</code>函数则会改变<code>vector</code>的实际大小，即元素的数量。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> <span class="hljs-built_in">resize</span>(size_type n);<br><span class="hljs-keyword">void</span> <span class="hljs-built_in">resize</span>(size_type n, value_type val);<br></code></pre></td></tr></table></figure><ul><li><code>vector</code>的大小将被设定为<code>n</code>。</li><li>如果<code>n</code>大于当前大小，<code>vector</code>将被扩展，并且新添加的元素将被初始化为<code>val</code>（如果没有指定<code>val</code>，则使用默认值初始化）。</li><li>如果<code>n</code>小于当前大小，<code>vector</code>的末尾元素将被删除，直到大小等于<code>n</code>。</li></ul><p>总结：</p><ul><li><code>reserve()</code>只改变<code>vector</code>的容量，而不改变其大小，主要用于性能优化，避免不必要的内存重新分配。</li><li><code>resize()</code>改变<code>vector</code>的大小，可能会初始化新元素或删除现有元素，用于改变<code>vector</code>中元素的数量。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>const在成员函数的前后作用</title>
    <link href="/2024/07/31/const%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%8D%E5%90%8E%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/07/31/const%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%8D%E5%90%8E%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="const在成员函数的前后作用"><a href="#const在成员函数的前后作用" class="headerlink" title="const在成员函数的前后作用"></a>const在成员函数的前后作用</h1><p>const在<strong>后面</strong>，表示这个成员函数<strong>不会修改成员变量</strong>，即这是一个常量的成员函数，修饰成员函数的属性；</p><p>const在<strong>前面</strong>，表示<strong>返回的引用不能被修改</strong>，不能通过返回的引用来修改成员变量。即返回值是const，修饰的是返回的变量。</p><p><strong>注意</strong>：<strong>常量只能调用常量的成员函数</strong>，不能调用非常量的成员函数。而非常量的成员函数可以调用非常量和常量的成员函数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大Vector作为局部变量返回注意事项</title>
    <link href="/2024/07/31/%E5%A4%A7Vector%E4%BD%9C%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%BF%94%E5%9B%9E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2024/07/31/%E5%A4%A7Vector%E4%BD%9C%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%BF%94%E5%9B%9E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="大Vector作为局部变量返回注意事项"><a href="#大Vector作为局部变量返回注意事项" class="headerlink" title="大Vector作为局部变量返回注意事项"></a>大Vector作为局部变量返回注意事项</h1><p>1、要注意避免拷贝或赋值操作，可以使用std::move移动语义，把左值变为一个右值引用，被外面一个左值接受。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">functionWithMoveReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(myVector);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2、防止栈溢出，可以把他分配在堆上，然后返回引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-title">functionWithRefReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;* myVector = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    <span class="hljs-keyword">return</span> *myVector;<br>&#125;<br><br><span class="hljs-comment">// 在使用完引用后手动释放内存</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; returnedVector = <span class="hljs-built_in">functionWithRefReturn</span>();<br><span class="hljs-comment">// 使用returnedVector...</span><br><span class="hljs-keyword">delete</span> &amp;returnedVector;<br><br></code></pre></td></tr></table></figure><p>3、把它变为全局或静态变量，这样不会保存在栈上，但是，使用全局变量或静态成员变量需要谨慎使用，因为它们可能会引入全局状态和潜在的并发访问问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-title">functionWithRefReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> myVector;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在Linux中如何通过一行命令找到文件夹里面的关键字</title>
    <link href="/2024/07/31/%E5%9C%A8Linux%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/07/31/%E5%9C%A8Linux%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="在Linux中如何通过一行命令找到文件夹里面的关键字"><a href="#在Linux中如何通过一行命令找到文件夹里面的关键字" class="headerlink" title="在Linux中如何通过一行命令找到文件夹里面的关键字"></a>在Linux中如何通过一行命令找到文件夹里面的关键字</h1><p><strong>1、find单独使用</strong><br><strong>2 、使用find+ xargs 进行操作</strong><br><strong>3、使用grep查找某目录下包含关键字内容的文件</strong></p><h2 id="1、find-单独使用："><a href="#1、find-单独使用：" class="headerlink" title="1、find 单独使用："></a>1、<code>find</code> 单独使用：</h2><p>&#96;&#96;find<code>命令用于在指定目录及其子目录中查找文件。你可以通过</code>-name<code>选项指定要搜索的文件名模式，然后使用</code>-exec&#96; 选项执行相应的操作。</p><p>示例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">find /path/to/directory -name <span class="hljs-string">&quot;*.txt&quot;</span> -<span class="hljs-keyword">exec</span> <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;keyword&quot;</span> &#123;&#125; \;<br><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">- `</span>/path/to/directory<span class="hljs-string">` 是要搜索的目录路径。</span><br><span class="hljs-string">- `</span>-name <span class="hljs-string">&quot;*.txt&quot;</span><span class="hljs-string">` 限定搜索的文件名模式为以 `</span>.txt<span class="hljs-string">` 结尾的文件。</span><br><span class="hljs-string">- `</span>-<span class="hljs-keyword">exec</span> <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;keyword&quot;</span> &#123;&#125; \;<span class="hljs-string">` 在找到的每个文件上执行 `</span><span class="hljs-keyword">grep</span><span class="hljs-string">` 命令，查找包含关键字 &quot;keyword&quot; 的行。</span><br></code></pre></td></tr></table></figure><h2 id="2、使用-find-xargs-进行操作："><a href="#2、使用-find-xargs-进行操作：" class="headerlink" title="2、使用 find + xargs 进行操作："></a>2、使用 <code>find + xargs</code> 进行操作：</h2><p>&#96;&#96;xargs<code>命令用于从标准输入中读取数据，并将其作为参数传递给其他命令。结合</code>find<code>和</code>xargs&#96; 可以在文件较多时提高效率。</p><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">find /path/to/directory -name <span class="hljs-string">&quot;*.txt&quot;</span> -print0 | xargs -<span class="hljs-number">0</span> grep <span class="hljs-string">&quot;keyword&quot;</span><br>```<br><br>解释：<br>- `-print0` 选项用于将 `find` 命令的输出以 null 字符分隔，确保处理文件名中包含空格或特殊字符的情况。<br>- `-<span class="hljs-number">0</span>` 选项用于告知 `xargs` 命令以 null 字符作为分隔符进行参数传递。<br>- `grep <span class="hljs-string">&quot;keyword&quot;</span>` 是要在找到的文件中查找的关键字。<br></code></pre></td></tr></table></figure><h2 id="3、使用-grep-查找某目录下包含关键字内容的文件："><a href="#3、使用-grep-查找某目录下包含关键字内容的文件：" class="headerlink" title="3、使用 grep 查找某目录下包含关键字内容的文件："></a>3、使用 <code>grep</code> 查找某目录下包含关键字内容的文件：</h2><p>&#96;&#96;grep&#96; 命令用于在文件中搜索指定模式或关键字，并输出匹配的行。</p><p>示例：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso">grep <span class="hljs-params">-r</span> <span class="hljs-string">&quot;keyword&quot;</span> /path/<span class="hljs-keyword">to</span>/directory<br><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">- `</span><span class="hljs-params">-r</span><span class="hljs-string">` 选项用于递归地搜索指定目录下的文件和子目录。</span><br><span class="hljs-string">- `</span><span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-string">` 是要查找的关键字。</span><br><span class="hljs-string">- `</span>/path/<span class="hljs-keyword">to</span>/directory<span class="hljs-string">` 是要搜索的目录路径。</span><br></code></pre></td></tr></table></figure><p>注意：以上命令的示例中，关键字 “keyword” 可替换为你要查找的实际关键字，而 <code>/path/to/directory</code> 可替换为要搜索的实际目录路径。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式的设计</title>
    <link href="/2024/07/31/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/07/31/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>意图：保证每一个类仅有<strong>一个实例</strong>，并为它提供一个<strong>全局访问</strong>点。（一些管理功能的类，需要统筹全局）</p><p><strong>如何保证单例模式是线程安全的</strong></p><ol><li><p>使用<strong>双重检查锁</strong>，先检查是否被初始化，然后在上锁，然后在检查是否被初始化，没有被初始化就初始化在返回。</p></li><li><p>使用静态局部变量，因为C++11中静态变量的初始化时线程安全的，具体而言，静态局部变量的初始化保证只发生一次，并且这个初始化过程是线程安全的。这意味着，即使多个线程同时访问同一个静态局部变量，它的初始化也只会执行一次，并且不会引起竞态条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">Instance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == value_)<br>&#123;<br>value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>&#125;<br><span class="hljs-keyword">return</span> *value_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton</span>();<br>~<span class="hljs-built_in">Singleton</span>();<br><br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;);<br>Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">delete</span> value_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//static pthread_once_t ponce_;</span><br><span class="hljs-type">static</span> T*             value_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* Singleton&lt;T&gt;::value_ = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure></li><li><p>可以在单线程模式下把单例类先初始化，比如main函数之前。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http-parser库的使用</title>
    <link href="/2024/07/31/http-parser%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/07/31/http-parser%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>http-parser库是C语言实现的，比较简单，仅仅支持HTTP&#x2F;1.0和HTTP&#x2F;1.1，支持边接收边解析，解析过程中可随时中断和恢复，比较轻量，每个连接仅需少量内存，既可以作为独立库集成到现有项目中，也可以作为构建自定义HTTP服务器的基础组件。</p><p>为了使用方便，需要进行封装</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>连不上云服务器mysql</title>
    <link href="/2024/07/31/%E8%BF%9E%E4%B8%8D%E4%B8%8A%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8mysql/"/>
    <url>/2024/07/31/%E8%BF%9E%E4%B8%8D%E4%B8%8A%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="连不上云服务器mysql"><a href="#连不上云服务器mysql" class="headerlink" title="连不上云服务器mysql"></a>连不上云服务器mysql</h1><p>原因：mysql只监听了本地回环地址，bind-address &#x3D; 127.0.0.1，可以使用<code>netstat -tulnp | grep mysql</code>命令查看是否是127.0.0.1，</p><p>解决步骤：</p><ol><li><p>打开MySQL配置文件。MySQL的配置文件通常位于<code>/etc/mysql/my.cnf</code>或者<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sudo nano <span class="hljs-string">/etc/mysql/mysql.conf.d/mysqld.cnf</span>  <br><br>*****<br>[mysqld]<br><span class="hljs-string">...</span><br>bind-address = 0.0.0.0    <span class="hljs-string">//</span>修改为这个后可以监听所有ip<br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>ctrl+x 按y保存后退出</p></li><li><p>重启mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart mysq<br></code></pre></td></tr></table></figure></li><li><p><code>netstat -tulnp | grep mysql</code>查看是否监听0.0.0.0</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>windows中使用socket</title>
    <link href="/2024/07/31/windows%E4%B8%AD%E4%BD%BF%E7%94%A8socket/"/>
    <url>/2024/07/31/windows%E4%B8%AD%E4%BD%BF%E7%94%A8socket/</url>
    
    <content type="html"><![CDATA[<h1 id="windows中使用socket前需要使用WSAStratup函数"><a href="#windows中使用socket前需要使用WSAStratup函数" class="headerlink" title="windows中使用socket前需要使用WSAStratup函数"></a>windows中使用socket前需要使用WSAStratup函数</h1><p><code>WSAStartup()</code>函数负责初始化Winsock DLL（动态链接库），它是Windows上实现Socket API的库。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">WSAData wsa;<br><span class="hljs-comment">//Winsock版本2.2</span><br><span class="hljs-comment">//1.1早期版本，功能不足，现在一般使用2.2</span><br><span class="hljs-built_in">WSAStartup</span>(MAKEWORD(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsa);  <br><span class="hljs-built_in">WSACleanup</span>();<br></code></pre></td></tr></table></figure><p><code>WSAStartup()</code>和<code>WSACleanup()</code>函数之间存在一种计数机制。每次调用<code>WSAStartup()</code>，都会增加一个计数器；而每次调用<code>WSACleanup()</code>，则会减少这个计数器。只有当计数器归零时，所有资源才会被释放，Winsock DLL才可能被卸载。这样设计是为了防止在应用程序的不同部分分别调用初始化和清理函数时可能出现的资源泄漏问题。</p><p><code>WSAStartup()</code>确保了Winsock DLL的线程安全特性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内存中的“cc”</title>
    <link href="/2024/07/31/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E2%80%9Ccc%E2%80%9D/"/>
    <url>/2024/07/31/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E2%80%9Ccc%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="内存中的“cc”"><a href="#内存中的“cc”" class="headerlink" title="内存中的“cc”"></a>内存中的“cc”</h1><p>代表的是十六进制数 <code>0xCC</code>，在汇编语言和低级编程中与 <code>int 3</code> 指令关联，当 CPU 遇到 <code>int 3</code> 指令时，它会触发一个异常，这通常被调试器捕获。</p><p>通常用于程序报错和调试，打断点的时候会有cc</p><p>未初始化的内存也有可能有cc，这个在调试模式下面可以告诉程序员这里出错了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>无法解析的外部命令问题</title>
    <link href="/2024/07/31/%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="无法解析的外部命令"><a href="#无法解析的外部命令" class="headerlink" title="无法解析的外部命令"></a>无法解析的外部命令</h1><p>1、有函数声明了但是没有实现</p><p>2、头文件A可能依赖于头文件B中的某个类型或声明。如果包含顺序颠倒，即先包含B后包含A，那么A中使用B中的类型或声明的部分可能在编译时找不到相应的定义，因为B还未被包含。</p><p>3、在C++中，如果一个头文件在命名空间外部定义了符号，而另一个头文件在命名空间内部定义了同名符号，那么包含顺序也可能导致链接错误，因为编译器可能无法正确解析这些符号的链接</p><h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__UuidCreate@4，函数 <span class="hljs-string">&quot;public: __thiscall RTSPSession::RTSPSession(class ESocket const &amp;)&quot;</span> (??<span class="hljs-number">0</span>RTSPSession@@QAE@ABVESocket@@@Z) 中引用了该符号<br></code></pre></td></tr></table></figure><p>缺库： <code>#pragma comment(lib, &quot;rpcrt4.lib&quot;)  </code></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__accept@12，函数 <span class="hljs-string">&quot;public: class ESocket __thiscall ESocket::Accept(class EAddress &amp;)&quot;</span> (?Accept@ESocket@@QAE?AV1@AAVEAddress@@@Z) 中引用了该符号<br><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__bind@12，函数 <span class="hljs-string">&quot;public: int __thiscall ESocket::Bind(class EAddress const &amp;)&quot;</span> (?Bind@ESocket@@QAEHABVEAddress@@@Z) 中引用了该符号<br><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__closesocket@4，函数 <span class="hljs-string">&quot;public: void __thiscall Socket::Close(void)&quot;</span> (?Close@Socket@@QAEXXZ) 中引用了该符号<br><span class="hljs-number">1</span>&gt;VideoRTSPServer.obj : <span class="hljs-keyword">error</span> LNK2001: 无法解析的外部符号 __imp__closesocket@4<br></code></pre></td></tr></table></figure><p>缺库：<code>#pragma comment(lib, &quot;ws2_32.lib&quot;) </code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>头文件循环引用和重定义问题</title>
    <link href="/2024/07/31/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="防止头文件循环引用"><a href="#防止头文件循环引用" class="headerlink" title="防止头文件循环引用"></a>防止头文件循环引用</h1><p>比如一个头文件a引用头文件b，头文件b需要引用头文件a，则需要在其中一个头文件中，比如在头文件b中使用a中类的声明，然后在b的cpp文件中使用a的头文件可以解决。</p><h1 id="头文件引发的重定义问题"><a href="#头文件引发的重定义问题" class="headerlink" title="头文件引发的重定义问题"></a>头文件引发的重定义问题</h1><p><strong>重定义产生的情况</strong></p><ul><li><p>情况一：<strong>多个源文件包含了同一个头文件时，如果头文件中有某个局部变量或者非内联函数的定义</strong>，那么相当于每个源文件都把该局部变量或者非内联函数定义了一次。而它们（局部变量或者非内联函数）在这种情况下默认又是全局的，那么自然会导致重定义错误。</p></li><li><p>情况二：某个源文件多次包含同一个头文件时，如果头文件中有定义语句，那么不管是什么东西的定义，都会产生重定义错误。</p></li></ul><p><strong>解决方法</strong></p><ul><li>针对情况一：我们应当避免在头文件中<strong>定义局部变量或者非内联函数</strong>。而由于编译器会将类，内联函数以及const变量默认视为定义它们的源文件所私有，因此它们（类，内联函数以及const变量）可以定义在头文件中。</li><li>针对情况二：使用ifndef或者pragma once</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ifndef和pragma once的区别</title>
    <link href="/2024/07/31/ifndef%E5%92%8Cpragma-once%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/31/ifndef%E5%92%8Cpragma-once%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="ifndef和pragma-once的区别"><a href="#ifndef和pragma-once的区别" class="headerlink" title="ifndef和pragma once的区别"></a>ifndef和pragma once的区别</h1><p><strong>1）#ifndef</strong></p><p> #ifndef的方式受C&#x2F;C++语言标准支持。它不仅可以保证<strong>同一个文件不会被包含多次</strong>，也能<strong>保证相同的代码段不会被重复包含</strong>（比如定义了相同的类）</p><p> 当然，<strong>缺点就是</strong></p><ul><li><p>如果不同头文件中的宏名（也就是ifndef后面的名字）不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷。</p></li><li><p>由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得<strong>编译时间相对较长</strong>，因此一些编译器逐渐开始支持#pragma once的方式。</p></li></ul><p><strong>2）#pragma once</strong></p><p> #pragma once 一般由编译器提供保证：<strong>同一个文件不会被包含多次</strong>。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。</p><p> <strong>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。</strong></p><p> <strong>好处</strong>：</p><ul><li>你<strong>不必再担心宏名冲突</strong>了，当然也就不会出现宏名冲突引发的奇怪问题。</li><li>大型项目的<strong>编译速度</strong>也因此提高了一些。</li></ul><p> 对应的<strong>缺点</strong></p><ul><li><p>如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种重复包含很容易被发现并修正。</p></li><li><p>不支持跨平台！</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt事件处理机制</title>
    <link href="/2024/07/31/Qt%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/31/Qt%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Qt事件处理机制"><a href="#Qt事件处理机制" class="headerlink" title="Qt事件处理机制"></a>Qt事件处理机制</h1><p><strong>事件</strong>：</p><ol><li>来源是系统中的中断，包括与Qt相关的中断（如硬件操作控制产生的中断）和程序中的定时器产生的中断</li><li>Qt程序中通过QEvent基类来表示各种类型的事件。</li></ol><p>QApplication对象负责监听整个应用程序中所有控件的事件。</p><p><strong>Qt事件处理器机制：</strong></p><p>​由exec执行的事件循环在监听整个应用程中所有事件，收到事件通知的控件通过过滤及分发函数，到达事件处理函数。</p><p><strong>事件与Qt信号槽的关系：</strong></p><ol><li>事件是信号槽中信号产生的基础，但两者不是一回事</li><li>事件解决本控件对应系统信号的响应问题，而信号槽则用于两个不相关控件之间的通信问题。</li></ol><h2 id="Qt底层维护的事件处理机制路径"><a href="#Qt底层维护的事件处理机制路径" class="headerlink" title="Qt底层维护的事件处理机制路径"></a>Qt底层维护的事件处理机制路径</h2><ul><li><strong>事件通知</strong>：QApplication中的bool notify(QObject* recver, QEvent* e)函数。</li><li><strong>事件过滤</strong>：eventFilter(QObject watched, QEvent* event)函数。</li><li><strong>事件分发</strong>：event(QEvent* e)函数。</li><li><strong>事件处理函数</strong>：受保护的虚函数。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt中的事件分发过程</title>
    <link href="/2024/07/31/Qt%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/07/31/Qt%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Qt中的事件分发过程"><a href="#Qt中的事件分发过程" class="headerlink" title="Qt中的事件分发过程"></a>Qt中的事件分发过程</h1><ol><li><p>当事件产生之后，Qt 使用应用程序对象<strong>调用 <code>notify()</code> 函数</strong>将事件发送到指定的窗口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-keyword">override</span> <span class="hljs-keyword">virtual</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QApplication::notify</span><span class="hljs-params">(QObject *receiver, QEvent *e)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>事件在发送过程中可以通过<strong>事件过滤器</strong>进行过滤，默认不对任何产生的事件进行过滤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-keyword">virtual</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QObject::eventFilter</span><span class="hljs-params">(QObject *watched, QEvent *event)</span></span><br></code></pre></td></tr></table></figure><p>需要先给窗口安装过滤器，该事件才会触发。</p></li><li><p>当事件发送到指定窗口之后，窗口的<strong>事件分发器</strong>会对收到的事件进行分类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-keyword">override</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QWidget::event</span><span class="hljs-params">(QEvent *event)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>事件分发器会将分类之后的事件（鼠标事件、键盘事件、绘图事件…）分发给对应的<strong>事件处理器函数</strong>进行处理，每个事件处理器函数都有默认的处理动作（我们也可以重写这些事件处理器函数），比如：鼠标事件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 鼠标按下</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br><br><span class="hljs-comment">// 鼠标释放</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br><br><span class="hljs-comment">// 鼠标移动</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>do ...while(false)</title>
    <link href="/2024/07/31/do-while-false/"/>
    <url>/2024/07/31/do-while-false/</url>
    
    <content type="html"><![CDATA[<p>do while(false)的作用：主要是为了<strong>能在这个代码块里面随时终止操作</strong>，比如<code>do...while(false)</code>块包含了文件的读取、数据的解码、JSON解析等操作，如果在任何一个环节出现问题（如文件打开失败、数据解码失败或JSON解析失败），代码会通过<code>break</code>语句跳出循环（正常是会在代码块里面返回），然后执行后面的清理或者默认操作。第二个作用是<strong>避免了在多个地方重复相同的清理代码</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程间传递文件套接字</title>
    <link href="/2024/07/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <url>/2024/07/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>unlink和close</title>
    <link href="/2024/07/31/unlink%E5%92%8Cclose/"/>
    <url>/2024/07/31/unlink%E5%92%8Cclose/</url>
    
    <content type="html"><![CDATA[<p><code>unlink</code>函数在这段代码中的作用是删除一个<strong>文件系统中的文件或者取消一个已命名的管道、套接字</strong>等。</p><p><code>unlink</code>操作成功后，如果还有其他进程已经打开了这个文件或套接字，它们仍然可以继续使用，直到它们也关闭了该文件描述符。</p><p>函数close是用来断开文件描述符和已打开文件之间的连接，并释放此文件描述符，以供其他文件使用。如果程序通过exit函数退出或者从主程序中返回，所有打开的文件将被关闭。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>函数unlink(char *name)将文件name从文件系统中删除，它对应于标准库函数remove。它会断开文件名与文件内容（inode）之间的链接。如果该文件没有其他硬链接且没有进程正在使用它，文件占用的存储空间会被回收。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>本地套接字与网络套接字的区别和用法</title>
    <link href="/2024/07/31/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/"/>
    <url>/2024/07/31/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>网络套接字</strong>是通过<strong>绑定ip和端口</strong>使网络中的进程之间进行通信，而<strong>本地套接字****是绑定套接字文件的路径名来使单机中的进程间通信</strong>,是一种IPC机制,其存储地址结构的数据类型为<code>struct sockaddr_un</code>,该数据类型包含在<code>#include&lt;sys/un.h&gt;</code>头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_un</span> &#123;<br><span class="hljs-type">sa_family_t</span> sun_family; <span class="hljs-comment">/*PF_UNIX或AF_UNIX */</span><br><span class="hljs-type">char</span> sun_path[UNIX_PATH_MAX]; <span class="hljs-comment">/* 路径名 */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>网络套接字客户端可以隐式绑定ip和端口，但是<strong>本地套接字客户端必须绑定套接字文件的路径名</strong>，否则无法通信(因为本地套接字通信模式中bind函数会创建套接字文件，两个进程之间的通信是通过各自的套接字文件来进行的)</p></li></ol><p>其他的跟网络套接字使用一样</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unix/Linux系统中的`fork()`系统调用</title>
    <link href="/2024/07/31/Unix-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2024/07/31/Unix-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>使用Unix&#x2F;Linux系统中的<code>fork()</code>系统调用时，需要注意的线程与进程之间的关系和潜在问题</p><ol><li><strong>线程无法被复制</strong>：<code>fork()</code>发生时，只有调用<code>fork()</code>的那个线程会被复制到子进程中，其他的线程不会被复制过去。</li><li><strong>破坏多线程模式</strong>：如果父进程中某个线程负责资源的初始化或清理，而在子进程中这个线程不存在，那么可能会导致资源未被正确管理，进而引发错误。</li><li><strong>先准备好进程结构，再去使用线程</strong>：涉及<code>fork()</code>和多线程的程序时，应该先明确进程的创建和初始化过程，确保在创建新的线程之前，进程的结构已经稳定。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于I/O 完成端口的多线程安全队列</title>
    <link href="/2024/07/26/%E5%9F%BA%E4%BA%8EI-O-%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/"/>
    <url>/2024/07/26/%E5%9F%BA%E4%BA%8EI-O-%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IOCP异步编程</title>
    <link href="/2024/07/26/IOCP%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/07/26/IOCP%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="iocp异步编程流程"><a href="#iocp异步编程流程" class="headerlink" title="iocp异步编程流程"></a>iocp异步编程流程</h1><ol><li><p><strong>创建I&#x2F;O完成端口</strong>: 使用<code>CreateIoCompletionPort</code>函数创建一个I&#x2F;O完成端口。这个端口将作为异步操作完成时的通知中心，需要与套接字关联。</p><blockquote><p><code>HANDLE CreateIoCompletionPort(  HANDLE FileHandle,  HANDLE ExistingCompletionPort,  ULONG_PTR CompletionKey,  DWORD NumberOfConcurrentThreads );</code></p><ol><li><strong>FileHandle</strong>：要与新创建或已存在的I&#x2F;O完成端口关联的文件句柄。首次创建IOCP传入<code>INVALID_HANDLE_VALUE</code>，表示仅创建一个空的I&#x2F;O完成端口。</li><li><strong>ExistingCompletionPort</strong>：一个已存在的I&#x2F;O完成端口句柄。如果想将<code>FileHandle</code>关联到这个已存在的I&#x2F;O完成端口上，就提供这个句柄；如果是要创建一个新的I&#x2F;O完成端口，则此参数应为<code>NULL</code>。</li><li><strong>CompletionKey</strong>：一个无符号长整数，由应用程序提供，作为完成键（Completion Key）。当一个I&#x2F;O操作完成时，这个键会随着完成通知一起返回给应用程序，用于标识完成的I&#x2F;O操作或与之关联的上下文。</li><li><strong>NumberOfConcurrentThreads</strong>：指定工作线程池中可以同时运行的线程的最大数目。如果设置为0，则系统将自动调整线程数量以达到最佳性能。通常，合理的线程数取决于系统的CPU核心数和I&#x2F;O负载。</li></ol><p>具体：<code>m_HIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 4);</code></p><ul><li>成功时，返回新创建或已关联的I&#x2F;O完成端口的句柄。</li><li>失败时，返回<code>NULL</code>，并可通过<code>GetLastError</code>获取错误码。</li></ul></blockquote></li><li><p><strong>创建并配置套接字</strong>: 使用<code>WSASocket</code>函数创建一个或多个套接字，并设置为使用重叠I&#x2F;O模型（通过<code>WSA_FLAG_OVERLAPPED</code>标志），允许套接字进行异步操作。</p><blockquote><p>具体：<code>m_servSocket = WSASocket(PF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);</code></p><ul><li><strong>af</strong>：地址族，如<code>AF_INET</code>用于IPv4或<code>AF_INET6</code>用于IPv6。</li><li><strong>type</strong>：套接字类型，如<code>SOCK_STREAM</code>用于TCP连接，<code>SOCK_DGRAM</code>用于UDP数据报。</li><li><strong>protocol</strong>：指定协议，通常为0，让系统根据<code>af</code>和<code>type</code>自动选择。</li><li><strong>lpProtocolInfo</strong>：指向一个<code>WSAPROTOCOL_INFO</code>结构的指针，允许直接指定协议信息，提供更细粒度的控制。</li><li><strong>g</strong>：保留，通常传入0。</li><li><strong>dwFlags</strong>：标志位，如<code>WSA_FLAG_OVERLAPPED</code>表示创建支持重叠I&#x2F;O的套接字，这对于使用IOCP模型是必需的。</li></ul></blockquote></li><li><p><strong>绑定套接字到I&#x2F;O完成端口</strong>: 再次使用<code>CreateIoCompletionPort</code>函数将每个套接字与之前创建的I&#x2F;O完成端口关联。这一步确保与这些套接字相关的I&#x2F;O操作完成时，通知将被发送到I&#x2F;O完成端口。</p><blockquote><p>具体：<code>CreateIoCompletionPort((HANDLE)m_servSocket, m_HIOCP, 0, 0)</code></p><ul><li><strong>m_servSocket</strong>：要关联的套接字；</li><li><strong>m_HIOCP</strong>：创建的完成端口</li></ul></blockquote></li><li><p><strong>初始化OVERLAPPED结构</strong>: 对于每个异步操作（如<code>ConnectEx</code>, <code>ReadFile</code>, <code>WriteFile</code>, <code>WSARecv</code>, <code>WSASend</code>等），都需要创建并初始化一个或多个<code>OVERLAPPED</code>结构（或其派生类），这个结构包含了操作的状态信息和完成时的回调参数。这里除了原始的OVERLAPPED，还包括连接的其他重要参数信息</p><blockquote><p><code>CMClient* pClient = new CMClient(this,m_HIOCP);</code></p></blockquote></li><li><p><strong>启动监听或连接操作</strong>: 根据需要，使用如<code>bind</code>, <code>listen</code>, <code>AcceptEx</code>等函数开始监听网络连接。对于客户端，可能直接使用<code>ConnectEx</code>进行异步连接。</p><blockquote><pre><code class="hljs">            AcceptEx(m_servSocket, pClient-&gt;m_clntSocket,                pClient-&gt;m_accept-&gt;m_buffer.data(),0,                sizeof(sockaddr_in) + 16,sizeof(sockaddr_in) + 16,                &amp;pClient-&gt;m_accept-&gt;m_received,&amp;pClient-&gt;m_accept-&gt;m_overlapped);</code></pre></blockquote></li><li><p><strong>发起异步I&#x2F;O操作</strong>: 当准备读取或写入数据时，使用相应的异步函数，如<code>WSARecv</code>和<code>WSASend</code>，并将之前准备好的<code>OVERLAPPED</code>结构传递给这些函数。<strong>这些操作会立即返回，而不会等待I&#x2F;O完成</strong>。</p></li><li><p><strong>等待并处理I&#x2F;O完成通知</strong>: 在主线程或一个专用的工作线程中，使用<code>GetQueuedCompletionStatus</code>循环等待I&#x2F;O完成的通知。当一个I&#x2F;O操作完成时，这些函数会返回，并提供完成键、传输的字节数、以及指向关联的<code>OVERLAPPED</code>结构的指针。</p><blockquote><p>取出<code>OVERLAPPED</code>结构的指针进行下一步的处理，这里可以把指针转换为一个结构体，涉及到类的下行转换，虽然说理论上是不安全的，但是这里也没有使用dynamic_cast进行强制类型转换，因为传进去的时候其实就是一个派生类的m_overlapped成员变量，自己知道这个下行转换是安全的</p></blockquote></li><li><p><strong>根据完成键和OVERLAPPED结构处理操作结果</strong>: 根据<code>OVERLAPPED</code>结构中的信息，确定操作类型（如读、写、接受连接等）并执行相应的后续处理。这可能包括数据处理、错误处理、再次发起读写操作等。然后就循环新连接，接受发送，然后等待异步处理</p></li></ol><p><strong>这里要注意的是如果是处理了一个新连接的时候要重新创建一个客户端socket然后与io完成端口绑定，才能接受新的连接</strong></p><h1 id="AcceptEx函数以及与accept函数的区别"><a href="#AcceptEx函数以及与accept函数的区别" class="headerlink" title="AcceptEx函数以及与accept函数的区别"></a>AcceptEx函数以及与accept函数的区别</h1><p><code>AcceptEx</code>函数是Winsock2 扩展API的一部分，专用于Windows平台，用于异步接受TCP连接请求。它相比传统的<code>accept</code>函数提供了更多的功能和灵活性。</p><h2 id="AcceptEx-函数介绍"><a href="#AcceptEx-函数介绍" class="headerlink" title="AcceptEx 函数介绍"></a>AcceptEx 函数介绍</h2><ul><li><strong>功能</strong>：<code>AcceptEx</code>函数允许服务器端在同一个调用中完成接受连接请求和接收连接套接字的<strong>初始化工作</strong>，同时还能<strong>从连接请求中提取客户端地址信息</strong>。它支持重叠I&#x2F;O模型，因此可以与I&#x2F;O完成端口（IOCP）结合，实现高效的异步接受处理。</li><li><strong>参数</strong>：<code>AcceptEx</code>接受多个参数，包括监听套接字、新的接受套接字（预先创建）、用于存储连接数据的缓冲区、缓冲区偏移量以及指向接收缓冲区大小和接收的地址信息的指针。它还接受一个<code>OVERLAPPED</code>结构的指针，用于异步操作的完成通知。</li><li><strong>缓冲区共享</strong>：<code>AcceptEx</code>使用一个共享的缓冲区来<strong>同时接收连接请求数据和客户端地址信息</strong>，这有助于减少系统调用和内存分配，提高效率。</li></ul><h2 id="与accept的区别"><a href="#与accept的区别" class="headerlink" title="与accept的区别"></a>与accept的区别</h2><ol><li><strong>异步支持</strong>：<code>accept</code>函数在默认情况下是<strong>阻塞</strong>的，即调用它时，如果没有新的连接请求到达，调用线程会被阻塞，直到连接请求到来。而<code>AcceptEx</code>设计用于异步操作，结合重叠I&#x2F;O和I&#x2F;O完成端口，可以避免阻塞，提高服务器的响应性和处理能力。</li><li><strong>连接初始化</strong>：<code>accept</code>函数接受连接后会返回一个新的套接字，而这个新套接字需要进一步的配置，如设置为非阻塞模式、绑定、设置选项等。<code>AcceptEx</code>则允许在函数调用时直接指定并初始化这个新套接字，减少了额外的配置步骤。</li><li><strong>数据接收</strong>：<code>AcceptEx</code>在接受连接的同时，可以读取连接请求的初始数据，<code>accept</code>不能。</li><li><strong>缓冲区管理</strong>：如前所述，<code>AcceptEx</code>使用共享缓冲区来存储连接数据和地址信息，而<code>accept</code>不涉及缓冲区管理，只负责接受连接。</li><li><strong>平台特定</strong>：<code>AcceptEx</code>是Windows特有的，而<code>accept</code>则是POSIX标准的一部分，跨平台兼容性更好。</li></ol><h1 id="设置重叠io的技巧"><a href="#设置重叠io的技巧" class="headerlink" title="设置重叠io的技巧"></a>设置重叠io的技巧</h1><p>​重叠io是关联了一个客户端连接的，具体的可以关联到一个客户端的某个操作，包括发送、接受、创建和关闭，也就是说重叠io是跟某一个客户端关联的，所以我们可以在重叠io这里设置了一个类，类里面的第一个成员变量是重叠io，后面的成员变量客户端连接的状态信息，包括客户端连接的上下文信息，I&#x2F;O操作类型，实际接受到的字节数，数据缓冲区这些信息。这样的话，在收到完成端口传出来的重叠io的时候就可以进行类型转换，然后得到这个客户端连接的状态信息。</p><p>​对于不同操作对应的重叠io，可以把它设置为一个重叠io的派生类，包括发送，接受，创建，关闭这四个派生类，派生类里面的关键是一个回调函数，每个操作都会有一个回调函数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池类设计</title>
    <link href="/2024/07/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/07/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>1 <strong>首先要先封装线程类</strong>。线程的创建、销毁、设置、启动、停止和主线程函数都要设置好接口。</p><p>2 <strong>然后设计线程池类</strong>。需要设计好接口：初始化、大小调整、添加任务、关闭、获取尺寸、启动等。线程池有一个任务列表属性，一个事件属性和一个互斥锁。外部投递进来的任务先是加入任务列表属性。然后设置事件属性。每个子线程都会等待事件。一旦事件被设置，则获取到该事件的线程就会通过互斥锁来同步任务列表，取其中一个任务出来开始执行。</p><p>3 <strong>设计任务类</strong>。任务类需要有一个任务函数接口。这个接口线程类会自动调用。此外需要封装一些做参数用的属性。一般任务类是基类，用户可以依据自己的需求去派生子类。子类重载任务函数即可，也可以自己追加一些属性，用于任务函数。</p><p>4 <strong>最后整合三个模块</strong>，一个最原始的线程池就完成了。</p><h1 id="任务类："><a href="#任务类：" class="headerlink" title="任务类："></a>任务类：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMFuncBase</span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(CMFuncBase::* MT_FUNC)</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMWork</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>CMFuncBase* thiz;<br>MT_FUNC     func;<br><span class="hljs-built_in">CMWork</span>(CMFuncBase* objThis, MT_FUNC objFunc)<br>&#123;<br>thiz= objThis;<br>func= objFunc;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (thiz-&gt;*func)();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMThread</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>std::atomic&lt;CMWork*&gt; m_work;<br>HANDLE               m_thread;<br>HANDLE m_event;<br><span class="hljs-type">bool</span> m_run;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadEntry</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>CMThread* thiz = (CMThread*)arg;<br>thiz-&gt;<span class="hljs-built_in">ThreadMain</span>();<br>_endthread();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadMain</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (m_run)<br>&#123;<br><span class="hljs-built_in">WaitForSingleObject</span>(m_event, INFINITE);<br><br><span class="hljs-type">int</span> ret = (*m_work)();<br><span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_work;<br>m_work = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">Notify</span>(<span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CMThread</span>()<br>&#123;<br>m_work = <span class="hljs-literal">NULL</span>;<br>m_thread = INVALID_HANDLE_VALUE;<br>m_event = <span class="hljs-built_in">CreateEvent</span>(<span class="hljs-literal">NULL</span>, FALSE, FALSE, <span class="hljs-literal">NULL</span>);<br>m_run = <span class="hljs-literal">true</span>;<br>&#125;<br>~<span class="hljs-built_in">CMThread</span>()<br>&#123;<br><span class="hljs-built_in">Stop</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(<span class="hljs-type">bool</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (b)<br>&#123;<br><span class="hljs-built_in">SetEvent</span>(m_event);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">ResetEvent</span>(m_event);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Work</span><span class="hljs-params">(<span class="hljs-type">const</span> CMWork&amp; work)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_work != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_work;<br>&#125;<br>m_work = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CMWork</span>(work);<br><span class="hljs-built_in">Notify</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_thread = (HANDLE)_beginthread(&amp;CMThread::ThreadEntry, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span> (m_thread == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程启动失败\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_run == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>m_run = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">WaitForSingleObject</span>(m_thread, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stop ret : %d\r\n&quot;</span>, ret);<br><span class="hljs-keyword">if</span> (ret == WAIT_OBJECT_0)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFree</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_run &amp;&amp; (m_work == <span class="hljs-literal">NULL</span>))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="线程池类"><a href="#线程池类" class="headerlink" title="线程池类"></a>线程池类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMThreadPool</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>std::vector&lt;CMThread*&gt;m_vecThreads;<br>std::mutexm_mutex;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CMThreadPool</span>(<span class="hljs-type">int</span> count)<br>&#123;<br>m_mutex.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br>m_vecThreads.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CMThread</span>());<br>&#125;<br>m_mutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br>~<span class="hljs-built_in">CMThreadPool</span>()<br>&#123;<br><span class="hljs-built_in">Stop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">delete</span> m_vecThreads.<span class="hljs-built_in">at</span>(i);<br>&#125;<br>m_mutex.<span class="hljs-built_in">lock</span>();<br>m_vecThreads.<span class="hljs-built_in">clear</span>();<br>m_mutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Invoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> isOk = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">Start</span>())<br>&#123;<br>isOk = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (isOk)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">Stop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> isOk = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">Stop</span>())<br>&#123;<br>isOk = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (isOk == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程关闭失败&quot;</span>);<br>&#125;<br><span class="hljs-comment">//assert(isOk);</span><br><span class="hljs-keyword">return</span> isOk;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispatchWork</span><span class="hljs-params">(<span class="hljs-type">const</span> CMWork&amp; work)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">IsFree</span>())<br>&#123;<br>m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">Work</span>(work);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>线程池测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>va_list的用法</title>
    <link href="/2024/07/21/va-list%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2024/07/21/va-list%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="VA-LIST的用法："><a href="#VA-LIST的用法：" class="headerlink" title="VA_LIST的用法："></a>VA_LIST的用法：</h1><ol><li><p>首先在函数里定义一具VA_LIST型的变量，这个变量是指向参数的指针； </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">va_list args<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>然后用VA_START宏初始化变量刚定义的VA_LIST变量； </p><p>使用<code>va_start</code>宏初始化<code>va_list</code>变量。<code>va_start</code>需要两个参数：<code>va_list</code>变量和最后一个固定参数（在…之前的参数）的地址。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">void my_printf(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">format</span>, ...) &#123;<br>    va_list <span class="hljs-keyword">args</span>;<br>    va_start(<span class="hljs-keyword">args</span>, <span class="hljs-keyword">format</span>); <span class="hljs-comment">// 注意：format是位于...之前的最后一个已知参数</span><br>    <span class="hljs-comment">// 接下来可以使用args访问可变参数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后用VA_ARG返回可变的参数，VA_ARG的第二个参数是你要返回的参数的类型（如果函数有多个可变参数的，依次调用VA_ARG获取各个参数）；</p><p><code>va_arg</code>需要两个参数：第一个是<code>va_list</code>变量，第二个是要获取的参数类型。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> arg_int = va_arg(args, <span class="hljs-keyword">int</span>); <span class="hljs-regexp">//</span> 获取一个<span class="hljs-keyword">int</span>类型的参数<br></code></pre></td></tr></table></figure></li><li><p>最后用VA_END宏结束可变参数的获取，清理操作，通常放在函数的末尾。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">va_end</span>(args);<br></code></pre></td></tr></table></figure></li></ol><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino">LogInfo::<span class="hljs-built_in">LogInfo</span>(<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">int</span> line, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* func,<br><span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">int</span> level,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...<br>)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> sLevel[][<span class="hljs-number">8</span>] = &#123;<br><span class="hljs-string">&quot;INFO&quot;</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>,<span class="hljs-string">&quot;WARNING&quot;</span>,<span class="hljs-string">&quot;ERROR&quot;</span>,<span class="hljs-string">&quot;FATAL&quot;</span><br>&#125;;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">NULL</span>;<br>bAuto = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//日志前缀</span><br><span class="hljs-type">int</span> count = <span class="hljs-built_in">asprintf</span>(&amp;buf, <span class="hljs-string">&quot;%s(%d):[%s][%s]&lt;%d-%d&gt;(%s) &quot;</span>,<br>file, line, sLevel[level],<br>(<span class="hljs-type">char</span>*)CLoggerServer::<span class="hljs-built_in">GetTimeStr</span>(), pid, tid, func);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf = buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//日志变参部分</span><br>va_list ap;<br><span class="hljs-built_in">va_start</span>(ap, fmt);<br>count = <span class="hljs-built_in">vasprintf</span>(&amp;buf, fmt, ap);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf += buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-built_in">va_end</span>(ap);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="额外知识："><a href="#额外知识：" class="headerlink" title="额外知识："></a>额外知识：</h2><p><code>vasprintf</code>是一个高级的变体，它结合了<code>vprintf</code>的功能（使用<code>va_list</code>参数列表格式化输出）和<code>asprintf</code>的能力（自动分配所需的缓冲区来存放结果字符串）。</p><p><code>asprintf</code>和<code>vsprintf</code>都是C语言中用于格式化输出字符串到动态分配的内存或预定义缓冲区的函数，它们都是<code>printf</code>系列函数的变体，主要用于处理可变参数列表。</p><h3 id="vsprintf"><a href="#vsprintf" class="headerlink" title="vsprintf"></a>vsprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, va_list arg)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>:</p><p><code>vsprintf</code>函数将<code>format</code>字符串中指定的格式化字符串写入到由<code>str</code>指向的缓冲区中。与<code>sprintf</code>类似，但它不是直接接受可变参数，而是通过一个<code>va_list</code>（由<code>va_start</code>初始化）来访问参数列表。</p><p><strong>参数</strong>:</p><ul><li><code>str</code>: 目标缓冲区的指针，必须足够大以容纳格式化后的字符串，否则会导致缓冲区溢出。</li><li><code>format</code>: 控制定制字符串格式的格式字符串，由普通文本和特殊的格式占位符组成，这些占位符指示如何处理并插入相应的参数值</li><li><code>arg</code>: 一个之前由<code>va_start</code>初始化的<code>va_list</code>，用于访问可变参数列表。</li></ul><h3 id="asprintf"><a href="#asprintf" class="headerlink" title="asprintf"></a>asprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">asprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> **strp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>: <code>asprintf</code>函数类似于<code>vsprintf</code>，但更加方便和安全，因为它会自动为格式化后的字符串分配内存，并通过<code>strp</code>返回指向这块内存的指针，<strong>调用者无需预先分配或担心缓冲区溢出问题</strong>。</p><p><strong>特点</strong>:</p><ul><li><code>asprintf</code>自动管理内存分配，改变指针指向</li><li>第三个参数是可变参数，而不是预先初始化好的可变参数列表va_list。</li></ul><p><strong>注意事项</strong>:</p><ul><li>动态分配的内存需要通过<code>free</code>手动释放，以防止内存泄漏。</li></ul><h3 id="vasprintf"><a href="#vasprintf" class="headerlink" title="vasprintf"></a>vasprintf</h3><p><code>vasprintf</code>会根据<code>fmt</code>和<code>ap</code>中的参数<strong>自动格式化字符串</strong>，并动态分配内存给结果字符串，然后修改了传入的<code>buf</code>（一个指针）的值，使其指向新分配的、包含格式化后字符串的内存区域，之后可以直接通过<code>buf</code>访问到这个新创建的字符串</p>]]></content>
    
    
    
    <tags>
      
      <tag>语言技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
