<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于I/O 完成端口的多线程安全队列</title>
    <link href="/2024/07/26/%E5%9F%BA%E4%BA%8EI-O-%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/"/>
    <url>/2024/07/26/%E5%9F%BA%E4%BA%8EI-O-%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IOCP异步编程</title>
    <link href="/2024/07/26/IOCP%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/07/26/IOCP%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="iocp异步编程流程"><a href="#iocp异步编程流程" class="headerlink" title="iocp异步编程流程"></a>iocp异步编程流程</h1><ol><li><p><strong>创建I&#x2F;O完成端口</strong>: 使用<code>CreateIoCompletionPort</code>函数创建一个I&#x2F;O完成端口。这个端口将作为异步操作完成时的通知中心，需要与套接字关联。</p><blockquote><p><code>HANDLE CreateIoCompletionPort(  HANDLE FileHandle,  HANDLE ExistingCompletionPort,  ULONG_PTR CompletionKey,  DWORD NumberOfConcurrentThreads );</code></p><ol><li><strong>FileHandle</strong>：要与新创建或已存在的I&#x2F;O完成端口关联的文件句柄。首次创建IOCP传入<code>INVALID_HANDLE_VALUE</code>，表示仅创建一个空的I&#x2F;O完成端口。</li><li><strong>ExistingCompletionPort</strong>：一个已存在的I&#x2F;O完成端口句柄。如果想将<code>FileHandle</code>关联到这个已存在的I&#x2F;O完成端口上，就提供这个句柄；如果是要创建一个新的I&#x2F;O完成端口，则此参数应为<code>NULL</code>。</li><li><strong>CompletionKey</strong>：一个无符号长整数，由应用程序提供，作为完成键（Completion Key）。当一个I&#x2F;O操作完成时，这个键会随着完成通知一起返回给应用程序，用于标识完成的I&#x2F;O操作或与之关联的上下文。</li><li><strong>NumberOfConcurrentThreads</strong>：指定工作线程池中可以同时运行的线程的最大数目。如果设置为0，则系统将自动调整线程数量以达到最佳性能。通常，合理的线程数取决于系统的CPU核心数和I&#x2F;O负载。</li></ol><p>具体：<code>m_HIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 4);</code></p><ul><li>成功时，返回新创建或已关联的I&#x2F;O完成端口的句柄。</li><li>失败时，返回<code>NULL</code>，并可通过<code>GetLastError</code>获取错误码。</li></ul></blockquote></li><li><p><strong>创建并配置套接字</strong>: 使用<code>WSASocket</code>函数创建一个或多个套接字，并设置为使用重叠I&#x2F;O模型（通过<code>WSA_FLAG_OVERLAPPED</code>标志），允许套接字进行异步操作。</p><blockquote><p>具体：<code>m_servSocket = WSASocket(PF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);</code></p><ul><li><strong>af</strong>：地址族，如<code>AF_INET</code>用于IPv4或<code>AF_INET6</code>用于IPv6。</li><li><strong>type</strong>：套接字类型，如<code>SOCK_STREAM</code>用于TCP连接，<code>SOCK_DGRAM</code>用于UDP数据报。</li><li><strong>protocol</strong>：指定协议，通常为0，让系统根据<code>af</code>和<code>type</code>自动选择。</li><li><strong>lpProtocolInfo</strong>：指向一个<code>WSAPROTOCOL_INFO</code>结构的指针，允许直接指定协议信息，提供更细粒度的控制。</li><li><strong>g</strong>：保留，通常传入0。</li><li><strong>dwFlags</strong>：标志位，如<code>WSA_FLAG_OVERLAPPED</code>表示创建支持重叠I&#x2F;O的套接字，这对于使用IOCP模型是必需的。</li></ul></blockquote></li><li><p><strong>绑定套接字到I&#x2F;O完成端口</strong>: 再次使用<code>CreateIoCompletionPort</code>函数将每个套接字与之前创建的I&#x2F;O完成端口关联。这一步确保与这些套接字相关的I&#x2F;O操作完成时，通知将被发送到I&#x2F;O完成端口。</p><blockquote><p>具体：<code>CreateIoCompletionPort((HANDLE)m_servSocket, m_HIOCP, 0, 0)</code></p><ul><li><strong>m_servSocket</strong>：要关联的套接字；</li><li><strong>m_HIOCP</strong>：创建的完成端口</li></ul></blockquote></li><li><p><strong>初始化OVERLAPPED结构</strong>: 对于每个异步操作（如<code>ConnectEx</code>, <code>ReadFile</code>, <code>WriteFile</code>, <code>WSARecv</code>, <code>WSASend</code>等），都需要创建并初始化一个或多个<code>OVERLAPPED</code>结构（或其派生类），这个结构包含了操作的状态信息和完成时的回调参数。这里除了原始的OVERLAPPED，还包括连接的其他重要参数信息</p><blockquote><p><code>CMClient* pClient = new CMClient(this,m_HIOCP);</code></p></blockquote></li><li><p><strong>启动监听或连接操作</strong>: 根据需要，使用如<code>bind</code>, <code>listen</code>, <code>AcceptEx</code>等函数开始监听网络连接。对于客户端，可能直接使用<code>ConnectEx</code>进行异步连接。</p><blockquote><pre><code class="hljs">            AcceptEx(m_servSocket, pClient-&gt;m_clntSocket,                pClient-&gt;m_accept-&gt;m_buffer.data(),0,                sizeof(sockaddr_in) + 16,sizeof(sockaddr_in) + 16,                &amp;pClient-&gt;m_accept-&gt;m_received,&amp;pClient-&gt;m_accept-&gt;m_overlapped);</code></pre></blockquote></li><li><p><strong>发起异步I&#x2F;O操作</strong>: 当准备读取或写入数据时，使用相应的异步函数，如<code>WSARecv</code>和<code>WSASend</code>，并将之前准备好的<code>OVERLAPPED</code>结构传递给这些函数。<strong>这些操作会立即返回，而不会等待I&#x2F;O完成</strong>。</p></li><li><p><strong>等待并处理I&#x2F;O完成通知</strong>: 在主线程或一个专用的工作线程中，使用<code>GetQueuedCompletionStatus</code>循环等待I&#x2F;O完成的通知。当一个I&#x2F;O操作完成时，这些函数会返回，并提供完成键、传输的字节数、以及指向关联的<code>OVERLAPPED</code>结构的指针。</p><blockquote><p>取出<code>OVERLAPPED</code>结构的指针进行下一步的处理，这里可以把指针转换为一个结构体，涉及到类的下行转换，虽然说理论上是不安全的，但是这里也没有使用dynamic_cast进行强制类型转换，因为传进去的时候其实就是一个派生类的m_overlapped成员变量，自己知道这个下行转换是安全的</p></blockquote></li><li><p><strong>根据完成键和OVERLAPPED结构处理操作结果</strong>: 根据<code>OVERLAPPED</code>结构中的信息，确定操作类型（如读、写、接受连接等）并执行相应的后续处理。这可能包括数据处理、错误处理、再次发起读写操作等。然后就循环新连接，接受发送，然后等待异步处理</p></li></ol><p><strong>这里要注意的是如果是处理了一个新连接的时候要重新创建一个客户端socket然后与io完成端口绑定，才能接受新的连接</strong></p><h1 id="AcceptEx函数以及与accept函数的区别"><a href="#AcceptEx函数以及与accept函数的区别" class="headerlink" title="AcceptEx函数以及与accept函数的区别"></a>AcceptEx函数以及与accept函数的区别</h1><p><code>AcceptEx</code>函数是Winsock2 扩展API的一部分，专用于Windows平台，用于异步接受TCP连接请求。它相比传统的<code>accept</code>函数提供了更多的功能和灵活性。</p><h2 id="AcceptEx-函数介绍"><a href="#AcceptEx-函数介绍" class="headerlink" title="AcceptEx 函数介绍"></a>AcceptEx 函数介绍</h2><ul><li><strong>功能</strong>：<code>AcceptEx</code>函数允许服务器端在同一个调用中完成接受连接请求和接收连接套接字的<strong>初始化工作</strong>，同时还能<strong>从连接请求中提取客户端地址信息</strong>。它支持重叠I&#x2F;O模型，因此可以与I&#x2F;O完成端口（IOCP）结合，实现高效的异步接受处理。</li><li><strong>参数</strong>：<code>AcceptEx</code>接受多个参数，包括监听套接字、新的接受套接字（预先创建）、用于存储连接数据的缓冲区、缓冲区偏移量以及指向接收缓冲区大小和接收的地址信息的指针。它还接受一个<code>OVERLAPPED</code>结构的指针，用于异步操作的完成通知。</li><li><strong>缓冲区共享</strong>：<code>AcceptEx</code>使用一个共享的缓冲区来<strong>同时接收连接请求数据和客户端地址信息</strong>，这有助于减少系统调用和内存分配，提高效率。</li></ul><h2 id="与accept的区别"><a href="#与accept的区别" class="headerlink" title="与accept的区别"></a>与accept的区别</h2><ol><li><strong>异步支持</strong>：<code>accept</code>函数在默认情况下是<strong>阻塞</strong>的，即调用它时，如果没有新的连接请求到达，调用线程会被阻塞，直到连接请求到来。而<code>AcceptEx</code>设计用于异步操作，结合重叠I&#x2F;O和I&#x2F;O完成端口，可以避免阻塞，提高服务器的响应性和处理能力。</li><li><strong>连接初始化</strong>：<code>accept</code>函数接受连接后会返回一个新的套接字，而这个新套接字需要进一步的配置，如设置为非阻塞模式、绑定、设置选项等。<code>AcceptEx</code>则允许在函数调用时直接指定并初始化这个新套接字，减少了额外的配置步骤。</li><li><strong>数据接收</strong>：<code>AcceptEx</code>在接受连接的同时，可以读取连接请求的初始数据，<code>accept</code>不能。</li><li><strong>缓冲区管理</strong>：如前所述，<code>AcceptEx</code>使用共享缓冲区来存储连接数据和地址信息，而<code>accept</code>不涉及缓冲区管理，只负责接受连接。</li><li><strong>平台特定</strong>：<code>AcceptEx</code>是Windows特有的，而<code>accept</code>则是POSIX标准的一部分，跨平台兼容性更好。</li></ol><h1 id="设置重叠io的技巧"><a href="#设置重叠io的技巧" class="headerlink" title="设置重叠io的技巧"></a>设置重叠io的技巧</h1><p>​重叠io是关联了一个客户端连接的，具体的可以关联到一个客户端的某个操作，包括发送、接受、创建和关闭，也就是说重叠io是跟某一个客户端关联的，所以我们可以在重叠io这里设置了一个类，类里面的第一个成员变量是重叠io，后面的成员变量客户端连接的状态信息，包括客户端连接的上下文信息，I&#x2F;O操作类型，实际接受到的字节数，数据缓冲区这些信息。这样的话，在收到完成端口传出来的重叠io的时候就可以进行类型转换，然后得到这个客户端连接的状态信息。</p><p>​对于不同操作对应的重叠io，我是把它设置为一个重叠io的派生类，包括发送，接受，创建，关闭这四个派生类，派生类里面的关键是一个回调函数，每个操作都会有一个回调函数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池类设计</title>
    <link href="/2024/07/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/07/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>1 <strong>首先要先封装线程类</strong>。线程的创建、销毁、设置、启动、停止和主线程函数都要设置好接口。</p><p>2 <strong>然后设计线程池类</strong>。需要设计好接口：初始化、大小调整、添加任务、关闭、获取尺寸、启动等。线程池有一个任务列表属性，一个事件属性和一个互斥锁。外部投递进来的任务先是加入任务列表属性。然后设置事件属性。每个子线程都会等待事件。一旦事件被设置，则获取到该事件的线程就会通过互斥锁来同步任务列表，取其中一个任务出来开始执行。</p><p>3 <strong>设计任务类</strong>。任务类需要有一个任务函数接口。这个接口线程类会自动调用。此外需要封装一些做参数用的属性。一般任务类是基类，用户可以依据自己的需求去派生子类。子类重载任务函数即可，也可以自己追加一些属性，用于任务函数。</p><p>4 <strong>最后整合三个模块</strong>，一个最原始的线程池就完成了。</p><p>线程池测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>va_list的用法</title>
    <link href="/2024/07/21/va-list%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2024/07/21/va-list%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="VA-LIST的用法："><a href="#VA-LIST的用法：" class="headerlink" title="VA_LIST的用法："></a>VA_LIST的用法：</h1><ol><li><p>首先在函数里定义一具VA_LIST型的变量，这个变量是指向参数的指针； </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">va_list args<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>然后用VA_START宏初始化变量刚定义的VA_LIST变量； </p><p>使用<code>va_start</code>宏初始化<code>va_list</code>变量。<code>va_start</code>需要两个参数：<code>va_list</code>变量和最后一个固定参数（在…之前的参数）的地址。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">void my_printf(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">format</span>, ...) &#123;<br>    va_list <span class="hljs-keyword">args</span>;<br>    va_start(<span class="hljs-keyword">args</span>, <span class="hljs-keyword">format</span>); <span class="hljs-comment">// 注意：format是位于...之前的最后一个已知参数</span><br>    <span class="hljs-comment">// 接下来可以使用args访问可变参数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后用VA_ARG返回可变的参数，VA_ARG的第二个参数是你要返回的参数的类型（如果函数有多个可变参数的，依次调用VA_ARG获取各个参数）；</p><p><code>va_arg</code>需要两个参数：第一个是<code>va_list</code>变量，第二个是要获取的参数类型。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> arg_int = va_arg(args, <span class="hljs-keyword">int</span>); <span class="hljs-regexp">//</span> 获取一个<span class="hljs-keyword">int</span>类型的参数<br></code></pre></td></tr></table></figure></li><li><p>最后用VA_END宏结束可变参数的获取，清理操作，通常放在函数的末尾。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">va_end</span>(args);<br></code></pre></td></tr></table></figure></li></ol><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino">LogInfo::<span class="hljs-built_in">LogInfo</span>(<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">int</span> line, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* func,<br><span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">int</span> level,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...<br>)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> sLevel[][<span class="hljs-number">8</span>] = &#123;<br><span class="hljs-string">&quot;INFO&quot;</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>,<span class="hljs-string">&quot;WARNING&quot;</span>,<span class="hljs-string">&quot;ERROR&quot;</span>,<span class="hljs-string">&quot;FATAL&quot;</span><br>&#125;;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">NULL</span>;<br>bAuto = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//日志前缀</span><br><span class="hljs-type">int</span> count = <span class="hljs-built_in">asprintf</span>(&amp;buf, <span class="hljs-string">&quot;%s(%d):[%s][%s]&lt;%d-%d&gt;(%s) &quot;</span>,<br>file, line, sLevel[level],<br>(<span class="hljs-type">char</span>*)CLoggerServer::<span class="hljs-built_in">GetTimeStr</span>(), pid, tid, func);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf = buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//日志变参部分</span><br>va_list ap;<br><span class="hljs-built_in">va_start</span>(ap, fmt);<br>count = <span class="hljs-built_in">vasprintf</span>(&amp;buf, fmt, ap);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf += buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-built_in">va_end</span>(ap);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="额外知识："><a href="#额外知识：" class="headerlink" title="额外知识："></a>额外知识：</h2><p><code>vasprintf</code>是一个高级的变体，它结合了<code>vprintf</code>的功能（使用<code>va_list</code>参数列表格式化输出）和<code>asprintf</code>的能力（自动分配所需的缓冲区来存放结果字符串）。</p><p><code>asprintf</code>和<code>vsprintf</code>都是C语言中用于格式化输出字符串到动态分配的内存或预定义缓冲区的函数，它们都是<code>printf</code>系列函数的变体，主要用于处理可变参数列表。</p><h3 id="vsprintf"><a href="#vsprintf" class="headerlink" title="vsprintf"></a>vsprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, va_list arg)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>:</p><p><code>vsprintf</code>函数将<code>format</code>字符串中指定的格式化字符串写入到由<code>str</code>指向的缓冲区中。与<code>sprintf</code>类似，但它不是直接接受可变参数，而是通过一个<code>va_list</code>（由<code>va_start</code>初始化）来访问参数列表。</p><p><strong>参数</strong>:</p><ul><li><code>str</code>: 目标缓冲区的指针，必须足够大以容纳格式化后的字符串，否则会导致缓冲区溢出。</li><li><code>format</code>: 控制定制字符串格式的格式字符串，由普通文本和特殊的格式占位符组成，这些占位符指示如何处理并插入相应的参数值</li><li><code>arg</code>: 一个之前由<code>va_start</code>初始化的<code>va_list</code>，用于访问可变参数列表。</li></ul><h3 id="asprintf"><a href="#asprintf" class="headerlink" title="asprintf"></a>asprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">asprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> **strp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>: <code>asprintf</code>函数类似于<code>vsprintf</code>，但更加方便和安全，因为它会自动为格式化后的字符串分配内存，并通过<code>strp</code>返回指向这块内存的指针，<strong>调用者无需预先分配或担心缓冲区溢出问题</strong>。</p><p><strong>特点</strong>:</p><ul><li><code>asprintf</code>自动管理内存分配，改变指针指向</li><li>第三个参数是可变参数，而不是预先初始化好的可变参数列表va_list。</li></ul><p><strong>注意事项</strong>:</p><ul><li>动态分配的内存需要通过<code>free</code>手动释放，以防止内存泄漏。</li></ul><h3 id="vasprintf"><a href="#vasprintf" class="headerlink" title="vasprintf"></a>vasprintf</h3><p><code>vasprintf</code>会根据<code>fmt</code>和<code>ap</code>中的参数<strong>自动格式化字符串</strong>，并动态分配内存给结果字符串，然后修改了传入的<code>buf</code>（一个指针）的值，使其指向新分配的、包含格式化后字符串的内存区域，之后可以直接通过<code>buf</code>访问到这个新创建的字符串</p>]]></content>
    
    
    
    <tags>
      
      <tag>语言技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
