<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>野指针和悬空指针的产生和避免</title>
    <link href="/2024/07/31/%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E9%81%BF%E5%85%8D/"/>
    <url>/2024/07/31/%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E9%81%BF%E5%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="野指针和悬空指针的产生和避免"><a href="#野指针和悬空指针的产生和避免" class="headerlink" title="野指针和悬空指针的产生和避免"></a>野指针和悬空指针的产生和避免</h1><p><strong>产生原因：</strong></p><ol><li>指针没有初始化； （野指针）</li><li>指针变量所指向的动态内存被释放后未设为 NULL； （悬空指针）</li><li>指针操作超越了变量的作用范围；比如返回了一个函数中局部变量的指针  （悬空指针）</li></ol><p><strong>避免野指针和悬空指针的出现</strong>，应当：</p><ul><li>确保所有指针在使用前已经初始化。</li><li>避免返回指向局部变量的指针。</li><li>在释放动态分配的内存后，立即将指针设置为 NULL。</li></ul><p><strong>野指针和悬空指针检测：</strong></p><p>​可以使用valgrind这个工具，它会在你的程序的每一条指令周围插入额外的检查代码，通过这些代码能够监控所有内存访问，如读取和写入操作，并检查它们是否合法。</p><p>​Valgrind 主要在程序运行时进行检测。从程序启动到结束，所有的内存访问和函数调用都会被监控。</p><p>​运行 Valgrind 后，会得到一个关于内存使用的详细报告：包括内存泄漏、野指针、数组越界、双重释放这些情况。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">valgrind <span class="hljs-attribute">--tool</span>=memcheck <span class="hljs-attribute">--leak-check</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">--show-reachable</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">--num-callers</span>=20 <span class="hljs-attribute">--track-fds</span>=<span class="hljs-literal">yes</span> ./your_program<br><br><br><span class="hljs-built_in">ERROR</span> SUMMARY: 1 errors <span class="hljs-keyword">from</span> 1 contexts (suppressed: 0 <span class="hljs-keyword">from</span> 0)<br>==<span class="hljs-attribute">12345</span>==    total heap usage: 10 allocs, 9 frees, 1,024 bytes allocated<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>值传递和引用传递</title>
    <link href="/2024/07/31/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <url>/2024/07/31/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h1 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h1><p><strong>1、值传递</strong></p><p>​值传递的本质是把实参的一个副本传递给形参，函数对形参的修改不会影响实参的值。值传递一般适用于传递基本数据类型（int，float等）和较小的对象，当不希望函数内部的操作影响到原始数据的时候也可以用。当对象太大，复制的成本较高就不适用值传递。</p><p><strong>2、引用传递</strong></p><p>​引用传递的本质是传递实参的引用给形参，所以在函数内部对形参的修改会同步到实参上。引用传递适用与传递较大的对象或者数组的时候，可以避免复制整个数据。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝和浅拷贝的区别</title>
    <link href="/2024/07/31/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/31/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h1><p>​浅拷贝就是复制对象的时候仅仅复制对象本身以及成员变量的值，不会复制成员变量所指向的内容。如果对象里面含有指针成员，浅拷贝会复制指针本身，不会复制指针指向的内容。</p><p>​它的特点就是比较快，缺点是可能会导致数据不一致或者指针悬挂，而且在多线程的情况下是不安全的。（线程安全是指在多线程的环境中，运行代码不会导致数据竞争或者其他不确定性的结果）</p><blockquote><p>​因为浅拷贝只会拷贝指针本身，所以原始对象和副本对象的指针都是指向同一块内存，一方修改另一方会收到影响，所以可能会导致数据不一致，而且如果两个对象都析构了，会导致指针被释放了两次，这中间可能会导致指针悬挂的问题（释放指针时候立即置为nullptr）。</p></blockquote><p>​<strong>深拷贝</strong>是指复制对象的时候不仅复制对象和成员变量的值，还复制成员变量所指向的内容。如果成员变量里面有指针，会分配一块新的内存，把指针指向的内容复制过去。</p><p>​它的特点是会比浅拷贝慢，但是原始对象和副本对象是独立的，不会互相影响。</p><hr><p>数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。</p><p>基本数据类型的特点：直接存储在<strong>栈</strong>(stack)中的数据<br>引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在<strong>堆</strong>内存里</p><p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><p><strong>浅拷贝</strong>：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p><p>简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象</p><p><strong>深拷贝</strong>：是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p>简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</p><h1 id="怎么实现深拷贝"><a href="#怎么实现深拷贝" class="headerlink" title="怎么实现深拷贝"></a>怎么实现深拷贝</h1>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性</title>
    <link href="/2024/07/31/C-11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2024/07/31/C-11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><h2 id="C-11的新特性有哪些"><a href="#C-11的新特性有哪些" class="headerlink" title="C++11的新特性有哪些"></a>C++11的新特性有哪些</h2><p>1、语法的改进<br>（1）<strong>统⼀的初始化⽅法</strong> ，{}<br>（2）成员变量默认初始化<br>（3）<strong>auto关键字</strong>： 允许编译器⾃动推断变量的类型，减少类型声明的冗余。<br>（4）decltype  求表达式的类型<br>（5）<strong>智能指针</strong> std::shared_ptr 和 std::unique_ptr<br>（6）<strong>空指针 nullptr</strong>: 把传统的NULL跟(void*) 0区分开来<br>（7）<strong>基于范围的for循环</strong>:  简化遍历容器元素的语法  。<br>（8）<strong>右值引⽤和move语义</strong>  引⼊右值引⽤和移动构造函数，允许⾼效地将资源从⼀个对象移动到另⼀个对 象，提⾼性能。 </p><p>2、标准库扩充（往STL⾥新加进⼀些模板类）<br>（9）⽆序容器（哈希表）  ⽤法和功能同map⼀模⼀样，区别在于哈希表的效率更⾼<br>（10）<strong>正则表达式</strong>  可以认为正则表达式实质上是⼀个字符串，该字符串描述了⼀种特定模式的字符串<br>（11）<strong>Lambda表达式</strong>： 允许在代码中定义匿名函数</p><h3 id="1、空指针nullptr"><a href="#1、空指针nullptr" class="headerlink" title="1、空指针nullptr"></a><strong>1、空指针nullptr</strong></h3><p>​在传统的C++里NULL会被识别为(void*)0，就是把NULL和0当成一个东西，而且C++不允许把 (void*)*隐式转换成其他类型，所以可能会导致导致C++的重载特性发生混乱，比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span></span>;<br></code></pre></td></tr></table></figure><p>如果此时传入的是NULL值，即func(NULL)，编译器可能会编译为func(0)，，从而调用func(int)。</p><h3 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a><strong>2、Lambda表达式</strong></h3><p>​Lambda是C++11的一种新的语法糖，提供了类似匿名函数的特性。在需要一个简短的函数，而不像费力去命名的时候可以使用。它的本质是**生成了一个匿名类的匿名对象，这个类重载了调用运算符()**，所以这个类由类似函数的行为。</p><p>​使用的时候从方括号开始，从花括号结束。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[捕获列表]</span> (传入参数) &#123;具体函数执行过程&#125;<br><span class="hljs-built_in">auto</span> basicLambda = [] &#123; cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!&quot;</span> &lt;&lt; endl; &#125;;<br><span class="hljs-built_in">auto</span> multiply = [](<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123; <span class="hljs-keyword">return</span> a * b; &#125;; <span class="hljs-comment">//可自动推导返回类型</span><br></code></pre></td></tr></table></figure><p>​其中<strong>捕获</strong>是 lambda 表达式的一个特性，它允许 lambda 表达式访问其函数定义外的局部变量，而不需要通过手动传参这种方式来使用</p><p>​<strong>优点：</strong></p><ol><li>对于一些简短函数来说，表达式更紧凑，可读性更好；</li><li>捕获特性可以更加访问外部的变量；</li></ol><p>​<strong>场景：</strong></p><ol><li><p>STL算法库</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span> = std::count_if(v.beigin(), v.<span class="hljs-keyword">end</span>(), [val](<span class="hljs-built_in">int</span> x) &#123; <span class="hljs-keyword">return</span> x &gt; val; &#125;);<br></code></pre></td></tr></table></figure></li><li><p>函数短小且不需要复用的时候</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sort(testdata<span class="hljs-selector-class">.begin</span>(), testdata<span class="hljs-selector-class">.end</span>(), <span class="hljs-selector-attr">[]</span>(int <span class="hljs-selector-tag">a</span>, int <span class="hljs-selector-tag">b</span>)&#123; return <span class="hljs-selector-tag">a</span> &gt; <span class="hljs-selector-tag">b</span>; &#125;);<br></code></pre></td></tr></table></figure></li><li><p>多线程场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::thread&gt; workers;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>   workers.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>([]() <br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;thread function\n&quot;</span>;<br>    &#125;));<br>&#125;<br><br>------------------------------------------------------------<br>std::mutex mutex;<br>std::condition_variable condition;<br>std::queue&lt;std::string&gt; queue_data;<br><br><span class="hljs-function">std::thread <span class="hljs-title">threadBody</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; lock_log(mutex);</span></span><br><span class="hljs-params"><span class="hljs-function">condition.wait(lock_log, [&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span> !queue_data.front();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;);</span></span><br><span class="hljs-params"><span class="hljs-function">std::cout &lt;&lt; <span class="hljs-string">&quot;queue data: &quot;</span> &lt;&lt; queue_data.front();</span></span><br><span class="hljs-params"><span class="hljs-function">lock_log.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="3、右值引用"><a href="#3、右值引用" class="headerlink" title="3、右值引用"></a><strong>3、右值引用</strong></h3><p>​在以前，右值是不允许被改变的，实践中也通常使⽤ const T&amp; 的⽅式传递右值 ，这样的方式有局限性，不能修改。引入右值引用后可以使用右值引用传参，可以修改。</p><p>​引入右值引用主要是为了实现移动语义，移动语义就是为了减少拷贝。std::move就是将左值转为右值引用，这样就可以重载到移动构造函数，移动构造函数只需要将指针赋值一下，不用再深拷贝，这样可以提高性能。</p><p>​<strong>有名字的右值引用是左值，匿名的会被当为右值。</strong>引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝。</p><p><strong>左值引用</strong>能指向左值，不能指向右值，除非加上const，因为const不会修改指向的值。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">//5是右值。</span><br></code></pre></td></tr></table></figure><p><strong>右值引用</strong>的标志为&amp;&amp;，可以指向右值，不能指向左值，但通过std::move可以把左值变为右值引用，从而间接指向左值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> &amp;&amp; <span class="hljs-built_in">ref</span>_a_right = <span class="hljs-number">5</span>;  <span class="hljs-comment">//ok</span><br><span class="hljs-built_in">int</span> &amp;&amp; <span class="hljs-built_in">ref</span>_a_right = a; <span class="hljs-comment">//不通过</span><br><span class="hljs-built_in">int</span> &amp;&amp; <span class="hljs-built_in">ref</span>_a_right = std::move(a);  <span class="hljs-comment">//ok </span><br></code></pre></td></tr></table></figure><p><strong>结论：</strong></p><ol><li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</li><li>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</li><li>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li></ol><p><strong>一些错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> ret = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>);<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(ret);  <span class="hljs-comment">// -&gt; return ret;</span><br>&#125;<br><span class="hljs-comment">//ret是非引用类型的返回值，即将离开作用域，会被C++当作是右值，原本的return会把它直接放到返回值的内存中构造；这个叫返回值优化；</span><br><span class="hljs-comment">//调用std::move后会调用移动构造函数，也避免了拷贝，所以是不必要的，而且还有可能导致性能下降。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bar</span><span class="hljs-params">(std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; val)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> val;    <span class="hljs-comment">// not compile</span><br>                 <span class="hljs-comment">// -&gt; return std::move/forward(val);</span><br>&#125;<br><span class="hljs-comment">//返回右值引用变量时，需要使用std::move/std::forward进行转换，因为val是左值。</span><br></code></pre></td></tr></table></figure><h3 id="4、泛化的常量表达式"><a href="#4、泛化的常量表达式" class="headerlink" title="4、泛化的常量表达式"></a><strong>4、泛化的常量表达式</strong></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span> = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> arr[<span class="hljs-built_in">N</span>]; //在C++ vector等变长数组中是可以通过的，在标准版本中数组大小必须是编译时的常量。所以这里会报错<br></code></pre></td></tr></table></figure><p>​constexpr告诉编译器这是一个编译期的常量，甚至可以把一个函数声明为编译期常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">getFive</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; &#125;<br><span class="hljs-type">int</span> arr[<span class="hljs-built_in">getFive</span>() + <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h3 id="5、初始化列表"><a href="#5、初始化列表" class="headerlink" title="5、初始化列表"></a><strong>5、初始化列表</strong></h3><p>​<strong>initializer_list</strong>  </p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>public:<br>A(std::initializer_list&lt;<span class="hljs-keyword">int</span>&gt; list);<br>&#125;;<br>A a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>​初始化列表时现有语法的增强，并不是提供动态的可变参数。这个列表只能静态的构造。</p><h3 id="6、统一的初始语法"><a href="#6、统一的初始语法" class="headerlink" title="6、统一的初始语法"></a><strong>6、统一的初始语法</strong></h3><p>​在之前不同的数据类型由不同的初始化语法，C++11之后均可使用“{}-初始化列表”：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span> x1 = X&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-attribute">X</span> x2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; // 此处的&#x27;=&#x27;可有可⽆<br><span class="hljs-attribute">X</span> x3&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-attribute">X</span>* p = new X&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7、类型推导"><a href="#7、类型推导" class="headerlink" title="7、类型推导"></a><strong>7、类型推导</strong></h3><p>​提供了<strong>auto</strong>和<strong>decltype</strong>来静态推导类型，在知道类型没有问题但是不想写出来的时候可以使用。</p><p>​decltype用于获取一个表达式的类型，不对表达式求值（类似sizeof），decltype(e)规则如下：</p><ul><li><p>若e为⼀个⽆括号的变量、函数参数、类成员，则返回类型为该变量&#x2F;参数&#x2F;类成员在源程序中的声明类型；  </p></li><li><p>否则的话，根据表达式的值分类（value categories），设设T 为 e 的类型：<br>1、若 e 是⼀个左值（lvalue，即“可寻址值”），返回 T&amp; ；<br>2、若 e 是⼀个临终值（xvalue），则返回值为 T&amp;&amp; ；<br>3、 若 e 是⼀个纯右值（prvalue），则返回值为 T 。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回临终值：⽣命周期已结束但内存还未拿⾛</span><br><span class="hljs-keyword">auto</span> a = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// a 为 int</span><br><span class="hljs-keyword">decltype</span>(v[<span class="hljs-number">0</span>]) b = <span class="hljs-number">0</span>; <span class="hljs-comment">// b 为 const int&amp;</span><br><span class="hljs-comment">// 即 vector&lt;int&gt;::operator[](size_type) const 的返回值类型</span><br><span class="hljs-keyword">auto</span> c = <span class="hljs-number">0</span>; <span class="hljs-comment">// c, d 均为 int</span><br><span class="hljs-keyword">auto</span> d = c;<br><span class="hljs-keyword">decltype</span>(c) e; <span class="hljs-comment">// e 为 int，即 c 的类型</span><br><span class="hljs-keyword">decltype</span>((c)) f = e; <span class="hljs-comment">// f 为 int&amp;，因为 c 是左值</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">0</span>) g; <span class="hljs-comment">// g 为 int，因为 0 是右值</span><br></code></pre></td></tr></table></figure><h3 id="8、基于范围的for循环"><a href="#8、基于范围的for循环" class="headerlink" title="8、基于范围的for循环"></a><strong>8、基于范围的for循环</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x: arr);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; x: arr);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x: v);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x: v);<br></code></pre></td></tr></table></figure><h3 id="9、构造委托函数"><a href="#9、构造委托函数" class="headerlink" title="9、构造委托函数"></a><strong>9、构造委托函数</strong></h3><p>​在 C# 和 Java 中，⼀个构造函数可以调⽤另⼀个来实现代码复⽤，但 C++⼀直不允许这样做。</p><p>​现在可以了，这使得<strong>构造函数可以在同⼀个类中⼀个构造函数调⽤另⼀个构造函数</strong>，从⽽达到简化代码的⽬的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">class myBase &#123;<br>int number; string name;<br><span class="hljs-built_in">myBase</span>( int i, string&amp; s ) : <span class="hljs-built_in">number</span>(i), <span class="hljs-built_in">name</span>(s)&#123;&#125;<br>public:<br><span class="hljs-built_in">myBase</span>( ) : <span class="hljs-built_in">myBase</span>( <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invalid&quot;</span> )&#123;&#125;<br><span class="hljs-built_in">myBase</span>( int i ) : <span class="hljs-built_in">myBase</span>( i, <span class="hljs-string">&quot;guest&quot;</span> )&#123;&#125;<br><span class="hljs-built_in">myBase</span>( string&amp; s ) : <span class="hljs-built_in">myBase</span>( <span class="hljs-number">1</span>, s )&#123; <span class="hljs-built_in">PostInit</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10、final和override"><a href="#10、final和override" class="headerlink" title="10、final和override"></a><strong>10、final和override</strong></h3><p>​C++ 借由虚函数实现运⾏时多态，但 C++ 的虚函数⼜很多脆弱的地⽅：</p><ul><li>⽆法禁⽌⼦类重写它。可能到某⼀层级时，我们不希望⼦类继续来重写当前虚函数了。</li><li>容易不⼩⼼隐藏⽗类的虚函数。⽐如在重写时，不⼩⼼声明了⼀个签名不⼀致但有同样名称的新函数。</li></ul><p>​C++11 提供了 <strong>final</strong> 来禁⽌虚函数被重写&#x2F;禁⽌类被继承， <strong>override</strong> 来显示地重写虚函数。 这样编译器给我们不⼩⼼的⾏为提供更多有⽤的错误和警告。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> Base1 final &#123; &#125;;<br><span class="hljs-keyword">struct</span> Derived1 : Base1 &#123;&#125;; <span class="hljs-comment">// 编译错： Base1不允许被继承</span><br><span class="hljs-keyword">struct</span> Base2 &#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span>() final</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span>()</span>;<br>&#125;;<br><span class="hljs-keyword">struct</span> Derived2 : Base2 &#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span>()</span>; <span class="hljs-comment">// 编译错： f1不允许重写</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// 编译错：⽗类中没有 void f2(int)</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="11、default和delete"><a href="#11、default和delete" class="headerlink" title="11、default和delete"></a><strong>11、default和delete</strong></h3><p>​我们知道编译器会为类⾃动⽣成⼀些⽅法，⽐如构造和析构函数（完整的列表⻅ Effective C++: Item 5）。现在我们可以显式地指定和禁⽌这些⾃动⾏为了。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">classA</span> &#123;<br><span class="hljs-built_in">classA</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 声明⼀个⾃动⽣成的函数</span><br><span class="hljs-built_in">classA</span>(T value);<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span> </span>= <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁⽌⽣成new运算符</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>​在上述 classA 中定义了 classA(T value) 构造函数，因此编译器不会默认⽣成⼀个⽆参数的构造函数了， 如果我们需要可以⼿动声明，或者直接 &#x3D; default 。  </p><h3 id="12、静态assertion"><a href="#12、静态assertion" class="headerlink" title="12、静态assertion"></a><strong>12、静态assertion</strong></h3><p>​C++ 提供了两种⽅式来 assert ：⼀种是 assert 宏，另⼀种是预处理指令 #error 。 前者在运⾏期起作⽤，⽽后者是预处理期起作⽤。它们对模板都不好使，因为模板是编译期的概念。 static_assert 关键字的使⽤⽅式如下：  </p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">Check</span> </span>&#123;<br>static_assert( sizeof(<span class="hljs-keyword">int</span>) &lt;= sizeof(T), <span class="hljs-string">&quot;T is not big enough!&quot;</span> ) ;<br>&#125; ;<br></code></pre></td></tr></table></figure><h3 id="13、智能指针"><a href="#13、智能指针" class="headerlink" title="13、智能指针"></a><strong>13、智能指针</strong></h3><p>​具体见智能指针</p><h3 id="14、正则表达式"><a href="#14、正则表达式" class="headerlink" title="14、正则表达式"></a><strong>14、正则表达式</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *reg_esp = <span class="hljs-string">&quot;[ ,.\\t\\n;:]&quot;</span>;<br>std::regex <span class="hljs-title function_ invoke__">rgx</span>(reg_esp) ;<br>std::cmatch <span class="hljs-keyword">match</span> ;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *target = <span class="hljs-string">&quot;Polytechnic University of Turin &quot;</span> ;<br><span class="hljs-keyword">if</span>( <span class="hljs-title function_ invoke__">regex_search</span>( target, <span class="hljs-keyword">match</span>, rgx ) ) &#123;<br><span class="hljs-keyword">const</span> size_t n = <span class="hljs-keyword">match</span>.<span class="hljs-title function_ invoke__">size</span>();<br><span class="hljs-keyword">for</span>( size_t a = <span class="hljs-number">0</span> ; a &lt; n ; a++ ) &#123;<br>string <span class="hljs-title function_ invoke__">str</span>( <span class="hljs-keyword">match</span>[a].first, <span class="hljs-keyword">match</span>[a].second ) ;<br>cout &lt;&lt; <span class="hljs-type">str</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> ;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="15、增强的元组"><a href="#15、增强的元组" class="headerlink" title="15、增强的元组"></a><strong>15、增强的元组</strong></h3><p>​在 C++ 中本已有⼀个 pair 模板可以定义⼆元组， C++11 更进⼀步地提供了边⻓参数的 tuple 模板  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::tuple&lt; <span class="hljs-type">int</span> , <span class="hljs-type">double</span>, string &gt; tuple_1 t1;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> std::tuple&lt; <span class="hljs-type">char</span>, <span class="hljs-type">short</span> , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * &gt; tuple_2 <span class="hljs-title">t2</span> <span class="hljs-params">(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Hola!&quot;</span>)</span></span>;<br>t1 = t2 ; <span class="hljs-comment">// 隐式类型转换</span><br></code></pre></td></tr></table></figure><h3 id="16、哈希表"><a href="#16、哈希表" class="headerlink" title="16、哈希表"></a><strong>16、哈希表</strong></h3><p>​C++ 的 map , multimap , set , multiset 使⽤红⿊树实现， 插⼊和查询都是 O(lgn) 的复杂度，但 C++11 为这四种模板类提供了（底层哈希实现）以达到 O(1) 的复杂度：  </p><table><thead><tr><th align="center">散列表类型</th><th align="center">有⽆关系值</th><th align="center">接受相同键值</th></tr></thead><tbody><tr><td align="center">std::unordered_set</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">std::unordered_multiset</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">std::unordered_map</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">std::unordered_multimap</td><td align="center">是</td><td align="center">是</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2024/07/31/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2024/07/31/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>从理论上来讲，任何类型的变量可以从任意地址开始存放。但是实际上计算机对基本数据类型在内存中的存放位置有限制，会要求数据首地址的值是某个数（通常是4或8）的整数倍，这就是内存对齐。</p><p>内存对齐是一种优化技术，其主要目的是提高内存访问速度。</p><p>对其规则有：</p><ol><li>基本类型的对齐值就是sizeof值。如果该成员是c++自带类型如int、char、double等，那么其对齐字节数&#x3D;该类型在内存中所占的字节数；如果该成员是自定义类型如某个class或者struct，那个它的对齐字节数 &#x3D; 该类型内最大的成员对齐字节数</li><li>结构体。结构体本身也要对齐，按照最大成员长度来参照的。</li><li>编译器可以设置最大对齐值，gcc中默认是#pragma pack(4)。但是类型的实际对齐值与默认对齐值取最小值来</li><li>如果设置了对齐字节数，就另说。①如果定义的字节数为1，就是所有默认字节数直接相加。②定义的字节数大于任何一个成员大小时候，不产生任何效果。如果定义的对齐字节数大于结构体内最小的，小于结构体内最大的话，就按照定义的字节数来计算</li></ol><h1 id="结构体内存分配"><a href="#结构体内存分配" class="headerlink" title="结构体内存分配"></a>结构体内存分配</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>        <span class="hljs-type">char</span> a;<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-type">short</span> c;<br>&#125;test1;<br><span class="hljs-comment">//1字节的成员a</span><br><span class="hljs-comment">//4字节的成员b</span><br><span class="hljs-comment">//2字节的成员c</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        test1 test;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test1.a = %p \n&quot;</span>,&amp;test.a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test1.b = %p \n&quot;</span>,&amp;test.b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test1.c = %p \n&quot;</span>,&amp;test.c);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>这里使用%p和引用&amp;来输出地址，也可以使用offsetof宏来测试，<strong>offsetof( type , member )</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;offsetof a = %d \n&quot;</span>,<span class="hljs-built_in">offsetof</span>(test1,a));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;offsetof b = %d \n&quot;</span>,<span class="hljs-built_in">offsetof</span>(test1,b));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;offsetof c = %d \n&quot;</span>,<span class="hljs-built_in">offsetof</span>(test1,c));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><p>运行结果：<br>a的地址为60FEF4。<br>b的地址为60FEF8。<br>c的地址为60FEFC。<br>成员a,b,c的地址依次递增，显然可以看出它们是按照结构体中的顺序进行排列的。</p><p>对于上面这个结构体来说，char类型占1个字节，int类型占用4个字节,short类型占用2个字节。那么总共应该占用1+2+4 &#x3D; 7个字节。</p><p>通过打印sizeof输出test1的大小，发现实际运行得到的test1的大小为12，并不是想当然的7。</p><p><strong>造成这一现象的原因有两点：</strong></p><p><strong>1.结构体内部的成员不是连续紧挨着存放的。每个结构体成员的存放地址都等于结构体起始地址加上自身类型长度的整数倍。</strong></p><p>​换成公式：<strong>成员的地址 &#x3D; 结构体起始地址 + 自身类型长度 * N</strong> (N为某个整数）</p><p>​<strong>在满足顺序存储的条件下，N尽可能小</strong>。</p><p>​<strong>想要减少结构体的空间占用，那么最好把数据类型相同的成员或者数据类型大小接近的成员放在一起，尽量避免不同大小的数据类型交错排列</strong>。这样便可以起到 节约空间的作用。</p><p><strong>2.结构体的大小是成员类型中最大类型的整数倍。</strong></p><blockquote><p><strong>总结</strong></p><ul><li><p><strong>结构体内的成员按照成员变量的声明顺序，依次存放在内存中。</strong></p></li><li><p><strong>结构体的大小是成员类型中最大类型的整数倍。</strong></p></li><li><p><strong>每个结构体成员的存放地址都等于结构体起始地址加上自身类型长度的整数倍</strong></p></li><li><p><strong>最重要的一点(具有实际意义)：声明结构体时，针对结构体里出现的所有成员变量，根据它们的类型大小进行降序声明</strong></p><p>导致这三个现象的原因就是所谓的<strong>内存对齐</strong>。目的为了<strong>加快寻址的处理速度</strong>。</p></li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++强制类型转换</title>
    <link href="/2024/07/31/C++%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/07/31/C++%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="C-强制类型转换有哪些方法"><a href="#C-强制类型转换有哪些方法" class="headerlink" title="C++强制类型转换有哪些方法"></a>C++强制类型转换有哪些方法</h1><p>有四个关键字：<code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast </code>和 <code>const_cast</code></p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>​主要用于<strong>基本类型之间的转换</strong>，比如把int转换成char，或者<strong>把其他类型的表达式转换成void类型</strong>。它是编译时的类型转换，没有运行时类型检查，所以在上行转换的时候是安全的，下行转换不安全；</p><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>​在下行转换的时候，dynamic_cast具有运行时类型检查功能，比static_cast安全。</p><blockquote><p>它是通过虚函数表来实现的，当创建对象的时候，虚函数指针会指向相应类的虚函数表，dynamic_cast就是使用这个虚函数表来判断对象的实际类型。所以使用的时候基类要有虚函数，而且转换之后必须是类的指针、引用或者void*。</p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//下行转换不安全</span><br>Animal* animal = new <span class="hljs-keyword">Cat</span>();<br><span class="hljs-keyword">Cat</span>* <span class="hljs-keyword">cat</span> = dynamic_cast&lt;<span class="hljs-keyword">Cat</span>*&gt;(animal);<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">cat</span>) &#123;<br>    <span class="hljs-keyword">cat</span>-&gt;makeSound(); <span class="hljs-comment">// 输出：Meow! I&#x27;m a cat.</span><br>&#125;<br><br>Dog* dog = dynamic_cast&lt;Dog*&gt;(animal);<br><span class="hljs-keyword">if</span> (dog) &#123;<br>    dog-&gt;makeSound(); <span class="hljs-comment">// 不会执行，因为animal实际上是Cat对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>​它可以把整型转换成指针，也可以把指针转换成数组。</p><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>​它可以把常量指针转换为非常量指针，并且仍然指向原来的对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span>：  <br>    void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">const</span> &#123;<br>        (const_cast&lt;Student*&gt;(<span class="hljs-keyword">this</span>))-&gt;roll = <span class="hljs-number">5</span>;<br>    &#125;<br>    <br><span class="hljs-comment">//普通成员函数里面的this指针是一个指向自身类型的常量指针，指针本身不能变，内容可以变；</span><br><span class="hljs-comment">//const成员函数里面的this指针是一个指向const对象的const指针，指针本身不能变，内容也不可以变。这个时候就只能读，不能改。</span><br><span class="hljs-comment">//这可以使用const_cast来类型转换为非const，指向非const内容</span><br><span class="hljs-comment">//有待验证</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器和指针有啥不同</title>
    <link href="/2024/07/31/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E6%9C%89%E5%95%A5%E4%B8%8D%E5%90%8C/"/>
    <url>/2024/07/31/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E6%9C%89%E5%95%A5%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器和指针的区别"><a href="#迭代器和指针的区别" class="headerlink" title="迭代器和指针的区别"></a>迭代器和指针的区别</h1><p><strong>迭代器：</strong><br>   （1）迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;,<em>,++ –等封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作；<br>   （2）迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用</em>取值后的值而不能直接输出其自身。<br>   （3）在设计模式中有一种模式叫迭代器模式，简单来说就是提供一种方法，在不需要暴露某个容器的内部表现形式情况下，使之能依次访问该容器中的各个元素，这种设计思维在STL中得到了广泛的应用，是STL的关键所在，通过迭代器，容器和算法可以有机的粘合在一起，只要对算法给予不同的迭代器，就可以对不同容器进行相同的操作。</p><p><strong>指针：</strong><br>    指针能指向函数而迭代器不行，迭代器只能指向容器；指针是迭代器的一种。指针只能用于某些特定的容器；迭代器是指针的抽象和泛化。所以，指针满足迭代器的一切要求。<br>    总之，指针和迭代器是有很大差别的，虽然他们表现的行为相似，但是本质是不一样的！一个是类模板，一个是存放一个家伙的地址的指针变量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类中使用成员初始化列表和构造函数内赋值的区别</title>
    <link href="/2024/07/31/C-%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%85%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/31/C-%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%85%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类中使用成员初始化列表和构造函数内赋值的区别："><a href="#C-类中使用成员初始化列表和构造函数内赋值的区别：" class="headerlink" title="C++类中使用成员初始化列表和构造函数内赋值的区别："></a>C++类中使用成员初始化列表和构造函数内赋值的区别：</h1><p><strong>注意事项：初始化顺序应该是成员变量声明顺序</strong></p><p><strong>1、效率高：</strong></p><p>​<strong>成员初始化列表</strong>：构造并初始化；</p><p>​<strong>构造函数内赋值</strong>：构造后给个默认值（初始化），赋值</p><p><strong>2、有些时候必须使用初始化列表</strong></p><ul><li><p>当我们初始化<code>const</code>或引用类型成员变量，因为这些类型的成员在构造函数体执行前必须已经初始化</p><ul><li><strong><code>const</code> 成员</strong>：一旦被构造，<code>const</code> 成员的值就不能改变，因此它必须在构造过程中立即获得其最终值。如果没有在成员初始化列表中初始化，就没有其他机会对其进行赋值操作。</li><li><strong>引用成员</strong>：引用必须在定义时被初始化，并且一旦指向一个对象，就不能再指向另一个对象。因此，引用成员也必须在构造函数的成员初始化列表中被初始化。</li></ul></li><li><p>对于继承自其他类的对象，如果基类没有默认构造函数，必须在初始化列表中明确调用基类的某个构造函数。</p><ul><li><strong>构造函数体内的代码是在所有成员（包括从基类继承的成员）已经被构造之后才会执行</strong>。因此，基类的构造函数必须在派生类任何成员初始化之前被调用，以保证基类的部分已经正确构造。这只能通过初始化列表来完成。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当调用某个类实例的成员函数的时候，编译器怎么工作的</title>
    <link href="/2024/07/31/%E5%BD%93%E8%B0%83%E7%94%A8%E6%9F%90%E4%B8%AA%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <url>/2024/07/31/%E5%BD%93%E8%B0%83%E7%94%A8%E6%9F%90%E4%B8%AA%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="当调用某个类实例的成员函数的时候，编译器怎么工作的"><a href="#当调用某个类实例的成员函数的时候，编译器怎么工作的" class="headerlink" title="当调用某个类实例的成员函数的时候，编译器怎么工作的"></a>当调用某个类实例的成员函数的时候，编译器怎么工作的</h1><p>​当你调用一个对象的成员函数时，编译器在源代码编译阶段和运行时阶段的操作是不同的。以下是这个过程的详细解释：</p><p>编译阶段：</p><ol><li><strong>确定函数地址</strong>：编译器在编译阶段会为所有函数生成代码。每个类的成员函数都具有一个唯一的地址，在编译时确定。编译器将这个地址与函数名和其所在类的类型结合在一起，存储在一个表（<strong>符号表</strong>）中。</li><li><strong>类型检查</strong>：当你在源代码中调用一个对象的成员函数时，编译器会进行类型检查，确保你调用的函数在该类型的对象上确实存在，并且你使用的参数和返回类型也是正确的。</li></ol><p>运行时阶段：</p><ol><li><strong>找到函数地址</strong>：运行时根据编译阶段存储的信息，确定所要调用的函数地址。</li><li><strong>进行函数调用</strong>：在调用函数时，需要创建一个新的栈帧以存储函数的局部变量和参数。同时，编译器还会将特殊的 “this” 指针作为隐含参数传递给成员函数。”this” 指针指向的是正在调用该成员函数的对象实例。这样，成员函数就可以访问它所属的对象实例的成员变量了。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static成员函数在调用时找到static成员变量的原理</title>
    <link href="/2024/07/31/static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%9C%A8%E8%B0%83%E7%94%A8%E6%97%B6%E6%89%BE%E5%88%B0static%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2024/07/31/static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%9C%A8%E8%B0%83%E7%94%A8%E6%97%B6%E6%89%BE%E5%88%B0static%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="static成员函数在调用时找到static成员变量的原理"><a href="#static成员函数在调用时找到static成员变量的原理" class="headerlink" title="static成员函数在调用时找到static成员变量的原理"></a>static成员函数在调用时找到static成员变量的原理</h1><p>​首先，所有的static成员变量（无论是在类中还是在函数中声明的）都被存储在程序的一个特殊区域，即静态存储区。每个static变量在内存中都有一个固定的地址。</p><p>​当你在static成员函数中使用这个static成员变量时，编译器会替换掉这个变量的引用，直接用这个变量在内存中的地址，这样就可以直接访问到这个变量。编译器在编译程序的时候，已经知道了所有static成员变量的内存地址，所以可以在编译时就直接将这些地址硬编码到生成的代码中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类中动态内存相关问题</title>
    <link href="/2024/07/31/%E7%B1%BB%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E7%B1%BB%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="类中动态内存相关问题"><a href="#类中动态内存相关问题" class="headerlink" title="类中动态内存相关问题"></a>类中动态内存相关问题</h1><p>不能在类声明中初始化静态成员变量，因为类声明只是描述了<strong>如何分配内存，但是不实际分配内存</strong>。但是如果静态成员是const或者枚举类型，则可以在类声明中初始化。</p><p>+++</p><p>问：为什么要有析构函数？</p><p>答：当删除类对象的时候可以释放掉对象本身所占用的内存，但是并不能自动释放属于对象成员指针所指向的内存。因此必须使用析构函数，在析构函数中使用delete来保证当对象过期时，可以释放掉由new所分配的内存。</p><p><strong>类创建中一些特殊的成员函数</strong></p><p>很多类中产生的问题都是由于特殊成员函数引起的，C++自动提供了下面这些成员函数：</p><ol><li>默认构造函数，如果没有定义构造函数</li><li>默认析构函数，如果没有定义</li><li>拷贝构造函数，如果没有定义</li><li>赋值运算符，如果没有定义</li><li>地址运算符，如果没有定义</li></ol><p>其中默认的拷贝构造函数和赋值运算符都是<strong>浅拷贝</strong>，如果类中有用new创建的动态变量，使用默认的会出现两次释放同一指针的问题，指针悬挂，程序乱码等，需要自己实现<strong>深拷贝的拷贝构造函数和赋值运算符</strong></p><p><strong>当在类中使用new时，应该注意一下几点：</strong></p><ol><li>如果在构造函数中用new初始化指针成员，那么在析构函数中应该使用delete</li><li>new和delete必须成对出现</li><li>应该定义一个复制构造函数，通过深拷贝将一个对象初始化为另一个对象</li><li>重载一个赋值运算符，通过深拷贝将一个对象复制给另一个对象。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类继承的问题</title>
    <link href="/2024/07/31/%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="基类与派生类特性"><a href="#基类与派生类特性" class="headerlink" title="基类与派生类特性"></a>基类与派生类特性</h2><p>创建派生类对象时，程序首先创建基类对象，也就是说<strong>基类对象应当在程序进入派生类构造函数之前被创建</strong>。c++使用成员初始化列表来完成。</p><p><strong>总结一下有关派生类构造函数的要点：</strong></p><ol><li>创建派生类对象前先创建基类对象</li><li>派生类构造函数应该通过成员初始化列表将基类信息传递给基类构造函数</li><li><strong>派生类构造函数应该初始化新增的数据成员</strong></li></ol><p>释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后执行基类的析构函数</p><hr><p><strong>派生类与基类之间有一些特殊的关系：</strong></p><ol><li><p>派生类对象可以使用基类的方法，条件是该方法不是私有的</p></li><li><p>基类指针可以在不进行显式类型转换的情况下指向派生类对象</p></li><li><p>基类引用可以在不进行显式类型转换的情况下引用派生类对象</p></li></ol><blockquote><p>注意事项：基类指针或引用确实可以指向派生类的对象，并且通过基类指针或引用，我们可以访问派生类中继承自基类的公有成员。但是如果派生类中重写了基类的函数那么，通过基类指针或引用调用该函数时，调用的具体版本（是基类的还是派生类的）取决于这个函数是否被声明为<code>virtual</code>。</p><ol><li>如果基类中的函数被声明为<code>virtual</code>，那么，当通过基类指针或引用调用该函数时，会调用对应的派生类版本（如果派生类中有重写该函数的话）。这被称作动态绑定或运行时多态性。</li><li>如果基类函数并未被声明为<code>virtual</code>，那么就没有动态绑定，只会调用基类版本不管指针或者引用是否指向派生类的实例。</li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector中的下标访问[]和at()</title>
    <link href="/2024/07/31/vector%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-%E5%92%8Cat/"/>
    <url>/2024/07/31/vector%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-%E5%92%8Cat/</url>
    
    <content type="html"><![CDATA[<h1 id="vector中的下标访问-和at-有何不同"><a href="#vector中的下标访问-和at-有何不同" class="headerlink" title="vector中的下标访问[]和at()有何不同"></a>vector中的下标访问[]和at()有何不同</h1><p><strong>下标运算符 <code>[]</code></strong></p><p>不进行边界检查，如果提供的索引超出范围，会导致未定义行为，导致程序崩溃</p><p><strong>成员函数 <code>at()</code></strong></p><p>访问元素之前会进行边界检查，如果提供的索引超出范围，会抛出 <code>std::out_of_range</code> 异常。</p><p>抛出异常可以使用try&#x2F;catch捕获和处理，try放可能异常的代码，catch捕获然后打印信息</p><p>相对于未定义行为，捕获异常更容易调试，定位问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reserve和resize的区别</title>
    <link href="/2024/07/31/reserve%E5%92%8Cresize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/31/reserve%E5%92%8Cresize%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="reserve和resize的区别"><a href="#reserve和resize的区别" class="headerlink" title="reserve和resize的区别"></a>reserve和resize的区别</h1><p><code>reserve()</code>函数用于预先分配足够的内存，以容纳指定数量的元素，但不会实际创建或初始化这些元素。它的主要目的是避免在多次添加元素时频繁地重新分配内存，从而提高性能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 预分配内存，但不初始化元素</span><br></code></pre></td></tr></table></figure><ul><li>如果<code>n</code>大于当前的<code>vector</code>容量，<code>vector</code>将分配足够的内存，以至少容纳<code>n</code>个元素。</li><li>如果<code>n</code>小于或等于当前的容量，<code>vector</code>的容量不会改变。</li><li><code>vector</code>的大小（元素数量）不会改变。</li></ul><p><code>resize()</code>函数则会改变<code>vector</code>的实际大小，即元素的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type n, value_type val)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>vector</code>的大小将被设定为<code>n</code>。</li><li>如果<code>n</code>大于当前大小，<code>vector</code>将被扩展，并且新添加的元素将被初始化为<code>val</code>（如果没有指定<code>val</code>，则使用默认值初始化）。</li><li>如果<code>n</code>小于当前大小，<code>vector</code>的末尾元素将被删除，直到大小等于<code>n</code>。</li></ul><p>总结：</p><ul><li><code>reserve()</code>只改变<code>vector</code>的容量，而不改变其大小，主要用于性能优化，避免不必要的内存重新分配。</li><li><code>resize()</code>改变<code>vector</code>的大小，可能会初始化新元素或删除现有元素，用于改变<code>vector</code>中元素的数量。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const在成员函数的前后作用</title>
    <link href="/2024/07/31/const%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%8D%E5%90%8E%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/07/31/const%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%8D%E5%90%8E%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="const在成员函数的前后作用"><a href="#const在成员函数的前后作用" class="headerlink" title="const在成员函数的前后作用"></a>const在成员函数的前后作用</h1><p>const在<strong>后面</strong>，表示这个成员函数<strong>不会修改成员变量</strong>，即这是一个常量的成员函数，修饰成员函数的属性；</p><p>const在<strong>前面</strong>，表示<strong>返回的引用不能被修改</strong>，不能通过返回的引用来修改成员变量。即返回值是const，修饰的是返回的变量。</p><p><strong>注意</strong>：<strong>常量只能调用常量的成员函数</strong>，不能调用非常量的成员函数。而非常量的成员函数可以调用非常量和常量的成员函数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大Vector作为局部变量返回注意事项</title>
    <link href="/2024/07/31/%E5%A4%A7Vector%E4%BD%9C%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%BF%94%E5%9B%9E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2024/07/31/%E5%A4%A7Vector%E4%BD%9C%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%BF%94%E5%9B%9E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="大Vector作为局部变量返回注意事项"><a href="#大Vector作为局部变量返回注意事项" class="headerlink" title="大Vector作为局部变量返回注意事项"></a>大Vector作为局部变量返回注意事项</h1><p>1、要注意避免拷贝或赋值操作，可以使用std::move移动语义，把左值变为一个右值引用，被外面一个左值接受。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">functionWithMoveReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(myVector);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2、防止栈溢出，可以把他分配在堆上，然后返回引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-title">functionWithRefReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;* myVector = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    <span class="hljs-keyword">return</span> *myVector;<br>&#125;<br><br><span class="hljs-comment">// 在使用完引用后手动释放内存</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; returnedVector = <span class="hljs-built_in">functionWithRefReturn</span>();<br><span class="hljs-comment">// 使用returnedVector...</span><br><span class="hljs-keyword">delete</span> &amp;returnedVector;<br><br></code></pre></td></tr></table></figure><p>3、把它变为全局或静态变量，这样不会保存在栈上，但是，使用全局变量或静态成员变量需要谨慎使用，因为它们可能会引入全局状态和潜在的并发访问问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-title">functionWithRefReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> myVector;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Linux中如何通过一行命令找到文件夹里面的关键字</title>
    <link href="/2024/07/31/%E5%9C%A8Linux%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/07/31/%E5%9C%A8Linux%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="在Linux中如何通过一行命令找到文件夹里面的关键字"><a href="#在Linux中如何通过一行命令找到文件夹里面的关键字" class="headerlink" title="在Linux中如何通过一行命令找到文件夹里面的关键字"></a>在Linux中如何通过一行命令找到文件夹里面的关键字</h1><p><strong>1、find单独使用</strong><br><strong>2 、使用find+ xargs 进行操作</strong><br><strong>3、使用grep查找某目录下包含关键字内容的文件</strong></p><h2 id="1、find-单独使用："><a href="#1、find-单独使用：" class="headerlink" title="1、find 单独使用："></a>1、<code>find</code> 单独使用：</h2><p>&#96;&#96;find<code>命令用于在指定目录及其子目录中查找文件。你可以通过</code>-name<code>选项指定要搜索的文件名模式，然后使用</code>-exec&#96; 选项执行相应的操作。</p><p>示例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">find /path/to/directory -name <span class="hljs-string">&quot;*.txt&quot;</span> -<span class="hljs-keyword">exec</span> <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;keyword&quot;</span> &#123;&#125; \;<br><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">- `</span>/path/to/directory<span class="hljs-string">` 是要搜索的目录路径。</span><br><span class="hljs-string">- `</span>-name <span class="hljs-string">&quot;*.txt&quot;</span><span class="hljs-string">` 限定搜索的文件名模式为以 `</span>.txt<span class="hljs-string">` 结尾的文件。</span><br><span class="hljs-string">- `</span>-<span class="hljs-keyword">exec</span> <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;keyword&quot;</span> &#123;&#125; \;<span class="hljs-string">` 在找到的每个文件上执行 `</span><span class="hljs-keyword">grep</span><span class="hljs-string">` 命令，查找包含关键字 &quot;keyword&quot; 的行。</span><br></code></pre></td></tr></table></figure><h2 id="2、使用-find-xargs-进行操作："><a href="#2、使用-find-xargs-进行操作：" class="headerlink" title="2、使用 find + xargs 进行操作："></a>2、使用 <code>find + xargs</code> 进行操作：</h2><p>&#96;&#96;xargs<code>命令用于从标准输入中读取数据，并将其作为参数传递给其他命令。结合</code>find<code>和</code>xargs&#96; 可以在文件较多时提高效率。</p><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">find /path/to/directory -name <span class="hljs-string">&quot;*.txt&quot;</span> -print0 | xargs -<span class="hljs-number">0</span> grep <span class="hljs-string">&quot;keyword&quot;</span><br>```<br><br>解释：<br>- `-print0` 选项用于将 `find` 命令的输出以 null 字符分隔，确保处理文件名中包含空格或特殊字符的情况。<br>- `-<span class="hljs-number">0</span>` 选项用于告知 `xargs` 命令以 null 字符作为分隔符进行参数传递。<br>- `grep <span class="hljs-string">&quot;keyword&quot;</span>` 是要在找到的文件中查找的关键字。<br></code></pre></td></tr></table></figure><h2 id="3、使用-grep-查找某目录下包含关键字内容的文件："><a href="#3、使用-grep-查找某目录下包含关键字内容的文件：" class="headerlink" title="3、使用 grep 查找某目录下包含关键字内容的文件："></a>3、使用 <code>grep</code> 查找某目录下包含关键字内容的文件：</h2><p>&#96;&#96;grep&#96; 命令用于在文件中搜索指定模式或关键字，并输出匹配的行。</p><p>示例：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso">grep <span class="hljs-params">-r</span> <span class="hljs-string">&quot;keyword&quot;</span> /path/<span class="hljs-keyword">to</span>/directory<br><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">- `</span><span class="hljs-params">-r</span><span class="hljs-string">` 选项用于递归地搜索指定目录下的文件和子目录。</span><br><span class="hljs-string">- `</span><span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-string">` 是要查找的关键字。</span><br><span class="hljs-string">- `</span>/path/<span class="hljs-keyword">to</span>/directory<span class="hljs-string">` 是要搜索的目录路径。</span><br></code></pre></td></tr></table></figure><p>注意：以上命令的示例中，关键字 “keyword” 可替换为你要查找的实际关键字，而 <code>/path/to/directory</code> 可替换为要搜索的实际目录路径。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式的设计</title>
    <link href="/2024/07/31/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/07/31/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>意图：保证每一个类仅有<strong>一个实例</strong>，并为它提供一个<strong>全局访问</strong>点。（一些管理功能的类，需要统筹全局）</p><p><strong>如何保证单例模式是线程安全的</strong></p><ol><li><p>使用<strong>双重检查锁</strong>，先检查是否被初始化，然后在上锁，然后在检查是否被初始化，没有被初始化就初始化在返回。</p></li><li><p>使用静态局部变量，因为C++11中静态变量的初始化时线程安全的，具体而言，静态局部变量的初始化保证只发生一次，并且这个初始化过程是线程安全的。这意味着，即使多个线程同时访问同一个静态局部变量，它的初始化也只会执行一次，并且不会引起竞态条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">Instance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == value_)<br>&#123;<br>value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>&#125;<br><span class="hljs-keyword">return</span> *value_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton</span>();<br>~<span class="hljs-built_in">Singleton</span>();<br><br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;);<br>Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">delete</span> value_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//static pthread_once_t ponce_;</span><br><span class="hljs-type">static</span> T*             value_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* Singleton&lt;T&gt;::value_ = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure></li><li><p>可以在单线程模式下把单例类先初始化，比如main函数之前。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http-parser库的使用</title>
    <link href="/2024/07/31/http-parser%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/07/31/http-parser%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>http-parser库是C语言实现的，比较简单，仅仅支持HTTP&#x2F;1.0和HTTP&#x2F;1.1，支持边接收边解析，解析过程中可随时中断和恢复，比较轻量，每个连接仅需少量内存，既可以作为独立库集成到现有项目中，也可以作为构建自定义HTTP服务器的基础组件。</p><p>因为是C语言实现的，为了使用方便，需要进行封装</p><p>首先包含http_parser.h和http_parser.c文件，</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连不上云服务器mysql</title>
    <link href="/2024/07/31/%E8%BF%9E%E4%B8%8D%E4%B8%8A%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8mysql/"/>
    <url>/2024/07/31/%E8%BF%9E%E4%B8%8D%E4%B8%8A%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="连不上云服务器mysql"><a href="#连不上云服务器mysql" class="headerlink" title="连不上云服务器mysql"></a>连不上云服务器mysql</h1><p>原因：mysql只监听了本地回环地址，bind-address &#x3D; 127.0.0.1，可以使用<code>netstat -tulnp | grep mysql</code>命令查看是否是127.0.0.1，</p><p>解决步骤：</p><ol><li><p>打开MySQL配置文件。MySQL的配置文件通常位于<code>/etc/mysql/my.cnf</code>或者<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sudo nano <span class="hljs-string">/etc/mysql/mysql.conf.d/mysqld.cnf</span>  <br><br>*****<br>[mysqld]<br><span class="hljs-string">...</span><br>bind-address = 0.0.0.0    <span class="hljs-string">//</span>修改为这个后可以监听所有ip<br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>ctrl+x 按y保存后退出</p></li><li><p>重启mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart mysq<br></code></pre></td></tr></table></figure></li><li><p><code>netstat -tulnp | grep mysql</code>查看是否监听0.0.0.0</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows中使用socket</title>
    <link href="/2024/07/31/windows%E4%B8%AD%E4%BD%BF%E7%94%A8socket/"/>
    <url>/2024/07/31/windows%E4%B8%AD%E4%BD%BF%E7%94%A8socket/</url>
    
    <content type="html"><![CDATA[<h1 id="windows中使用socket前需要使用WSAStratup函数"><a href="#windows中使用socket前需要使用WSAStratup函数" class="headerlink" title="windows中使用socket前需要使用WSAStratup函数"></a>windows中使用socket前需要使用WSAStratup函数</h1><p><code>WSAStartup()</code>函数负责初始化Winsock DLL（动态链接库），它是Windows上实现Socket API的库。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">WSAData wsa;<br><span class="hljs-comment">//Winsock版本2.2</span><br><span class="hljs-comment">//1.1早期版本，功能不足，现在一般使用2.2</span><br><span class="hljs-built_in">WSAStartup</span>(MAKEWORD(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsa);  <br><span class="hljs-built_in">WSACleanup</span>();<br></code></pre></td></tr></table></figure><p><code>WSAStartup()</code>和<code>WSACleanup()</code>函数之间存在一种计数机制。每次调用<code>WSAStartup()</code>，都会增加一个计数器；而每次调用<code>WSACleanup()</code>，则会减少这个计数器。只有当计数器归零时，所有资源才会被释放，Winsock DLL才可能被卸载。这样设计是为了防止在应用程序的不同部分分别调用初始化和清理函数时可能出现的资源泄漏问题。</p><p><code>WSAStartup()</code>确保了Winsock DLL的线程安全特性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存中的“cc”</title>
    <link href="/2024/07/31/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E2%80%9Ccc%E2%80%9D/"/>
    <url>/2024/07/31/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E2%80%9Ccc%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="内存中的“cc”"><a href="#内存中的“cc”" class="headerlink" title="内存中的“cc”"></a>内存中的“cc”</h1><p>代表的是十六进制数 <code>0xCC</code>，在汇编语言和低级编程中与 <code>int 3</code> 指令关联，当 CPU 遇到 <code>int 3</code> 指令时，它会触发一个异常，这通常被调试器捕获。</p><p>通常用于程序报错和调试，打断点的时候会有cc</p><p>未初始化的内存也有可能有cc，这个在调试模式下面可以告诉程序员这里出错了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无法解析的外部命令问题</title>
    <link href="/2024/07/31/%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="无法解析的外部命令"><a href="#无法解析的外部命令" class="headerlink" title="无法解析的外部命令"></a>无法解析的外部命令</h1><p>1、有函数声明了但是没有实现</p><p>2、头文件A可能依赖于头文件B中的某个类型或声明。如果包含顺序颠倒，即先包含B后包含A，那么A中使用B中的类型或声明的部分可能在编译时找不到相应的定义，因为B还未被包含。</p><p>3、在C++中，如果一个头文件在命名空间外部定义了符号，而另一个头文件在命名空间内部定义了同名符号，那么包含顺序也可能导致链接错误，因为编译器可能无法正确解析这些符号的链接</p><h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__UuidCreate@4，函数 <span class="hljs-string">&quot;public: __thiscall RTSPSession::RTSPSession(class ESocket const &amp;)&quot;</span> (??<span class="hljs-number">0</span>RTSPSession@@QAE@ABVESocket@@@Z) 中引用了该符号<br></code></pre></td></tr></table></figure><p>缺库： <code>#pragma comment(lib, &quot;rpcrt4.lib&quot;)  </code></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__accept@12，函数 <span class="hljs-string">&quot;public: class ESocket __thiscall ESocket::Accept(class EAddress &amp;)&quot;</span> (?Accept@ESocket@@QAE?AV1@AAVEAddress@@@Z) 中引用了该符号<br><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__bind@12，函数 <span class="hljs-string">&quot;public: int __thiscall ESocket::Bind(class EAddress const &amp;)&quot;</span> (?Bind@ESocket@@QAEHABVEAddress@@@Z) 中引用了该符号<br><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__closesocket@4，函数 <span class="hljs-string">&quot;public: void __thiscall Socket::Close(void)&quot;</span> (?Close@Socket@@QAEXXZ) 中引用了该符号<br><span class="hljs-number">1</span>&gt;VideoRTSPServer.obj : <span class="hljs-keyword">error</span> LNK2001: 无法解析的外部符号 __imp__closesocket@4<br></code></pre></td></tr></table></figure><p>缺库：<code>#pragma comment(lib, &quot;ws2_32.lib&quot;) </code></p>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>头文件循环引用和重定义问题</title>
    <link href="/2024/07/31/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="防止头文件循环引用"><a href="#防止头文件循环引用" class="headerlink" title="防止头文件循环引用"></a>防止头文件循环引用</h1><p>比如一个头文件a引用头文件b，头文件b需要引用头文件a，则需要在其中一个头文件中，比如在头文件b中使用a中类的声明，然后在b的cpp文件中使用a的头文件可以解决。</p><h1 id="头文件引发的重定义问题"><a href="#头文件引发的重定义问题" class="headerlink" title="头文件引发的重定义问题"></a>头文件引发的重定义问题</h1><p><strong>重定义产生的情况</strong></p><ul><li><p>情况一：<strong>多个源文件包含了同一个头文件时，如果头文件中有某个局部变量或者非内联函数的定义</strong>，那么相当于每个源文件都把该局部变量或者非内联函数定义了一次。而它们（局部变量或者非内联函数）在这种情况下默认又是全局的，那么自然会导致重定义错误。</p></li><li><p>情况二：某个源文件多次包含同一个头文件时，如果头文件中有定义语句，那么不管是什么东西的定义，都会产生重定义错误。</p></li></ul><p><strong>解决方法</strong></p><ul><li>针对情况一：我们应当避免在头文件中<strong>定义局部变量或者非内联函数</strong>。而由于编译器会将类，内联函数以及const变量默认视为定义它们的源文件所私有，因此它们（类，内联函数以及const变量）可以定义在头文件中。</li><li>针对情况二：使用ifndef或者pragma once</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ifndef和pragma once的区别</title>
    <link href="/2024/07/31/ifndef%E5%92%8Cpragma-once%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/31/ifndef%E5%92%8Cpragma-once%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="ifndef和pragma-once的区别"><a href="#ifndef和pragma-once的区别" class="headerlink" title="ifndef和pragma once的区别"></a>ifndef和pragma once的区别</h1><p><strong>1）#ifndef</strong></p><p> #ifndef的方式受C&#x2F;C++语言标准支持。它不仅可以保证<strong>同一个文件不会被包含多次</strong>，也能<strong>保证相同的代码段不会被重复包含</strong>（比如定义了相同的类）</p><p> 当然，<strong>缺点就是</strong></p><ul><li><p>如果不同头文件中的宏名（也就是ifndef后面的名字）不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷。</p></li><li><p>由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得<strong>编译时间相对较长</strong>，因此一些编译器逐渐开始支持#pragma once的方式。</p></li></ul><p><strong>2）#pragma once</strong></p><p> #pragma once 一般由编译器提供保证：<strong>同一个文件不会被包含多次</strong>。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。</p><p> <strong>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。</strong></p><p> <strong>好处</strong>：</p><ul><li>你<strong>不必再担心宏名冲突</strong>了，当然也就不会出现宏名冲突引发的奇怪问题。</li><li>大型项目的<strong>编译速度</strong>也因此提高了一些。</li></ul><p> 对应的<strong>缺点</strong></p><ul><li><p>如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种重复包含很容易被发现并修正。</p></li><li><p>不支持跨平台！</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt事件处理机制</title>
    <link href="/2024/07/31/Qt%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/31/Qt%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Qt事件处理机制"><a href="#Qt事件处理机制" class="headerlink" title="Qt事件处理机制"></a>Qt事件处理机制</h1><p><strong>事件</strong>：</p><ol><li>来源是系统中的中断，包括与Qt相关的中断（如硬件操作控制产生的中断）和程序中的定时器产生的中断</li><li>Qt程序中通过QEvent基类来表示各种类型的事件。</li></ol><p>QApplication对象负责监听整个应用程序中所有控件的事件。</p><p><strong>Qt事件处理器机制：</strong></p><p>​由exec执行的事件循环在监听整个应用程中所有事件，收到事件通知的控件通过过滤及分发函数，到达事件处理函数。</p><p><strong>事件与Qt信号槽的关系：</strong></p><ol><li>事件是信号槽中信号产生的基础，但两者不是一回事</li><li>事件解决本控件对应系统信号的响应问题，而信号槽则用于两个不相关控件之间的通信问题。</li></ol><h2 id="Qt底层维护的事件处理机制路径"><a href="#Qt底层维护的事件处理机制路径" class="headerlink" title="Qt底层维护的事件处理机制路径"></a>Qt底层维护的事件处理机制路径</h2><ul><li><strong>事件通知</strong>：QApplication中的bool notify(QObject* recver, QEvent* e)函数。</li><li><strong>事件过滤</strong>：eventFilter(QObject watched, QEvent* event)函数。</li><li><strong>事件分发</strong>：event(QEvent* e)函数。</li><li><strong>事件处理函数</strong>：受保护的虚函数。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt中的事件分发过程</title>
    <link href="/2024/07/31/Qt%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/07/31/Qt%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Qt中的事件分发过程"><a href="#Qt中的事件分发过程" class="headerlink" title="Qt中的事件分发过程"></a>Qt中的事件分发过程</h1><ol><li><p>当事件产生之后，Qt 使用应用程序对象<strong>调用 <code>notify()</code> 函数</strong>将事件发送到指定的窗口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[<span class="hljs-keyword">override</span> <span class="hljs-keyword">virtual</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QApplication::notify</span><span class="hljs-params">(QObject *receiver, QEvent *e)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>事件在发送过程中可以通过<strong>事件过滤器</strong>进行过滤，默认不对任何产生的事件进行过滤。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[<span class="hljs-keyword">virtual</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QObject::eventFilter</span><span class="hljs-params">(QObject *watched, QEvent *event)</span></span><br></code></pre></td></tr></table></figure><p>需要先给窗口安装过滤器，该事件才会触发。</p></li><li><p>当事件发送到指定窗口之后，窗口的<strong>事件分发器</strong>会对收到的事件进行分类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[<span class="hljs-keyword">override</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QWidget::event</span><span class="hljs-params">(QEvent *event)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>事件分发器会将分类之后的事件（鼠标事件、键盘事件、绘图事件…）分发给对应的<strong>事件处理器函数</strong>进行处理，每个事件处理器函数都有默认的处理动作（我们也可以重写这些事件处理器函数），比如：鼠标事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 鼠标按下</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br><br><span class="hljs-comment">// 鼠标释放</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br><br><span class="hljs-comment">// 鼠标移动</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>do ...while(false)用法</title>
    <link href="/2024/07/31/do-while-false/"/>
    <url>/2024/07/31/do-while-false/</url>
    
    <content type="html"><![CDATA[<h1 id="do-while-false-的作用："><a href="#do-while-false-的作用：" class="headerlink" title="do while(false)的作用："></a>do while(false)的作用：</h1><p>主要是为了<strong>能在这个代码块里面随时终止操作</strong>，比如<code>do...while(false)</code>块包含了文件的读取、数据的解码、JSON解析等操作，如果在任何一个环节出现问题（如文件打开失败、数据解码失败或JSON解析失败），代码会通过<code>break</code>语句跳出循环（正常是会在代码块里面返回），然后执行后面的清理或者默认操作。第二个作用是<strong>避免了在多个地方重复相同的清理代码</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间传递文件套接字</title>
    <link href="/2024/07/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <url>/2024/07/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unlink和close</title>
    <link href="/2024/07/31/unlink%E5%92%8Cclose/"/>
    <url>/2024/07/31/unlink%E5%92%8Cclose/</url>
    
    <content type="html"><![CDATA[<p><code>unlink</code>函数在这段代码中的作用是删除一个<strong>文件系统中的文件或者取消一个已命名的管道、套接字</strong>等。</p><p><code>unlink</code>操作成功后，如果还有其他进程已经打开了这个文件或套接字，它们仍然可以继续使用，直到它们也关闭了该文件描述符。</p><p>函数close是用来断开文件描述符和已打开文件之间的连接，并释放此文件描述符，以供其他文件使用。如果程序通过exit函数退出或者从主程序中返回，所有打开的文件将被关闭。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>函数unlink(char *name)将文件name从文件系统中<strong>删除</strong>，它对应于标准库函数remove。它会断开文件名与文件内容（inode）之间的链接。如果该文件没有其他硬链接且没有进程正在使用它，文件占用的存储空间会被回收。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span>;<br></code></pre></td></tr></table></figure><p>unlink会把文件删掉，close只是关闭</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程</title>
    <link href="/2024/07/31/socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/07/31/socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP的Socket编程"><a href="#TCP的Socket编程" class="headerlink" title="TCP的Socket编程"></a>TCP的Socket编程</h1><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p><h1 id="UDPsocket流程"><a href="#UDPsocket流程" class="headerlink" title="UDPsocket流程"></a>UDPsocket流程</h1><p>udp的流程则更为简单，客户端仅仅需要两个步骤（socket和sendto），而服务器端也仅仅需要三个步骤即可接收到来自客户端的消息（socket、bind、recvfrom）</p><p><img src="/image/1093303-20170115195937619-2089905370.jpg" alt="img"></p><h1 id="socket代码"><a href="#socket代码" class="headerlink" title="socket代码"></a>socket代码</h1><p>无论是TCP还是UDP，无论是客户端还是服务端，无论是网络套接字还是本地套接字，都可以大致分为初始化、连接、发送、接受、关闭四个步骤，只是TCP和UDP，或者客户端和服务端，在具体每个步骤锁执行的东西有些许差异，所以可以做一个统一的封装.</p><p><img src="/image/image-20240802162429964.png" alt="image-20240802162429964"></p><h2 id="socket参数"><a href="#socket参数" class="headerlink" title="socket参数"></a>socket参数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SockAttr</span> &#123;<br>    SOCK_ISSERVER = <span class="hljs-number">1</span>,  <span class="hljs-comment">//是否服务器 1表示是 0表示客户端</span><br>    SOCK_ISNONBLOCK = <span class="hljs-number">2</span>,  <span class="hljs-comment">//是否阻塞 1表示非阻塞 0表示阻塞</span><br>    SOCK_ISUDP = <span class="hljs-number">4</span>,   <span class="hljs-comment">//是否为UDP 1表示udp 0表示tcp</span><br>    SOCK_ISIP = <span class="hljs-number">8</span>,  <span class="hljs-comment">//是否为IP协议 1表示IP协议 0表示本地套接字</span><br>    SOCK_ISREUSE = <span class="hljs-number">16</span>  <span class="hljs-comment">//是否重用地址</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSockParam</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSockParam</span>()<br>        : <span class="hljs-built_in">port</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">attr</span>(<span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 默认是客户端、阻塞、tcp</span><br>        <span class="hljs-built_in">bzero</span>(&amp;addr_in, <span class="hljs-built_in">sizeof</span>(addr_in));<br>        <span class="hljs-built_in">bzero</span>(&amp;addr_un, <span class="hljs-built_in">sizeof</span>(addr_un));<br>    &#125;<br><br>    <span class="hljs-built_in">CSockParam</span>(<span class="hljs-type">const</span> Buffer&amp; ip, <span class="hljs-type">short</span> port, <span class="hljs-type">int</span> attr)<br>        : <span class="hljs-built_in">ip</span>(ip), <span class="hljs-built_in">port</span>(port), <span class="hljs-built_in">attr</span>(attr) &#123;<br>        addr_in.sin_family = AF_INET;<br>        addr_in.sin_port = <span class="hljs-built_in">htons</span>(port);  <span class="hljs-comment">//主机字节序转为网络字节序</span><br>        addr_in.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(ip.<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-built_in">CSockParam</span>(<span class="hljs-type">const</span> sockaddr_in* addrin, <span class="hljs-type">int</span> attr)<br>        : <span class="hljs-built_in">ip</span>(ip), <span class="hljs-built_in">port</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">attr</span>(attr) &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;addr_in, addrin, <span class="hljs-built_in">sizeof</span>(addr_in));<br>    &#125;<br><br>    <span class="hljs-built_in">CSockParam</span>(<span class="hljs-type">const</span> Buffer&amp; path, <span class="hljs-type">int</span> attr)<br>        : <span class="hljs-built_in">ip</span>(path), <span class="hljs-built_in">port</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">attr</span>(attr) &#123;<br>        addr_un.sun_family = AF_UNIX;<br>        <span class="hljs-built_in">strncpy</span>(addr_un.sun_path, path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(addr_un.sun_path) - <span class="hljs-number">1</span>); <span class="hljs-comment">// 确保不会发生缓冲区溢出</span><br>    &#125;<br><br>    <span class="hljs-built_in">CSockParam</span>(<span class="hljs-type">const</span> CSockParam&amp; param)<br>        : <span class="hljs-built_in">ip</span>(param.ip), <span class="hljs-built_in">port</span>(param.port), <span class="hljs-built_in">attr</span>(param.attr) &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;addr_in, &amp;param.addr_in, <span class="hljs-built_in">sizeof</span>(addr_in));<br>        <span class="hljs-built_in">memcpy</span>(&amp;addr_un, &amp;param.addr_un, <span class="hljs-built_in">sizeof</span>(addr_un));<br>    &#125;<br><br>    CSockParam&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CSockParam&amp; param) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;param) &#123;<br>            ip = param.ip;<br>            port = param.port;<br>            attr = param.attr;<br>            <span class="hljs-built_in">memcpy</span>(&amp;addr_in, &amp;param.addr_in, <span class="hljs-built_in">sizeof</span>(addr_in));<br>            <span class="hljs-built_in">memcpy</span>(&amp;addr_un, &amp;param.addr_un, <span class="hljs-built_in">sizeof</span>(addr_un));<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function">sockaddr* <span class="hljs-title">addrin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr_in); &#125;<br>    <span class="hljs-function">sockaddr* <span class="hljs-title">addrun</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr_un); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> sockaddr* <span class="hljs-title">addrin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> sockaddr*&gt;(&amp;addr_in); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> sockaddr* <span class="hljs-title">addrun</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> sockaddr*&gt;(&amp;addr_un); &#125;<br><br><br><span class="hljs-keyword">public</span>:<br>    sockaddr_in addr_in;  <span class="hljs-comment">//网络套接字地址</span><br>    sockaddr_un addr_un;  <span class="hljs-comment">//本地套接字地址</span><br>    Buffer ip;<br>    <span class="hljs-type">short</span> port;<br>    <span class="hljs-type">int</span> attr;  <span class="hljs-comment">//参考SockAttr</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="socket抽象类"><a href="#socket抽象类" class="headerlink" title="socket抽象类"></a>socket抽象类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSocketBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSocketBase</span>() : <span class="hljs-built_in">m_socket</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">m_status</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CSocketBase</span>() &#123;<br>        <span class="hljs-built_in">Close</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> CSockParam&amp; param)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Link</span><span class="hljs-params">(CSocketBase** pClient = <span class="hljs-literal">nullptr</span>)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">const</span> Buffer&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Recv</span><span class="hljs-params">(Buffer&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_socket; &#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-type">const</span> sockaddr_in*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> &amp;m_param.addr_in; &#125;<br>    <span class="hljs-keyword">operator</span> sockaddr_in*() &#123; <span class="hljs-keyword">return</span> &amp;m_param.addr_in; &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_socket;  <span class="hljs-comment">//默认-1</span><br>    <span class="hljs-type">int</span> m_status;  <span class="hljs-comment">//0初始化未完成 1初始化完成 2连接完成 3已经关闭</span><br>    CSockParam m_param;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="TCP-socket子类"><a href="#TCP-socket子类" class="headerlink" title="TCP socket子类"></a>TCP socket子类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSocket</span> : <span class="hljs-keyword">public</span> CSocketBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSocket</span>() : <span class="hljs-built_in">m_socket</span>(<span class="hljs-number">-1</span>) &#123;&#125; <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CSocket</span><span class="hljs-params">(<span class="hljs-type">int</span> sock)</span> : m_socket(sock) &#123;</span>&#125; <br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CSocket</span>() &#123;<br>        <span class="hljs-built_in">Close</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> CSockParam&amp; param)</span> <span class="hljs-keyword">override</span></span>;  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Link</span><span class="hljs-params">(CSocketBase** pClient = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">const</span> Buffer&amp; data)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Recv</span><span class="hljs-params">(Buffer&amp; data)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EnsureSocketInitialized</span><span class="hljs-params">(<span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SetupSocketOptions</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BindAndListen</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ConnectToAddress</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-function">std::unique_ptr&lt;CSocket&gt; <span class="hljs-title">AcceptConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-type">int</span> m_socket; <br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSocket.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-keyword">using</span> Buffer = std::string;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Server</span>(<span class="hljs-type">const</span> CSockParam&amp; param) : <span class="hljs-built_in">m_socket</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CSocket</span>()), <span class="hljs-built_in">m_param</span>(param) &#123;<br>        <span class="hljs-keyword">if</span> (m_socket-&gt;<span class="hljs-built_in">Init</span>(m_param) != <span class="hljs-number">0</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Server initialization failed.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Server</span>() &#123;<br>        <span class="hljs-keyword">delete</span> m_socket;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;<br>        CSocketBase* client = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> ret = m_socket-&gt;<span class="hljs-built_in">Link</span>(&amp;client);<br>        <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Server connection failed.&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Server: Connection established.&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-function">Buffer <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello from server&quot;</span>)</span></span>;<br>        ret = <span class="hljs-built_in">static_cast</span>&lt;CSocket*&gt;(client)-&gt;<span class="hljs-built_in">Send</span>(data);<br>        <span class="hljs-keyword">if</span> (ret  != <span class="hljs-number">0</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Server: Failed to send data.&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Server: Data sent.&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">delete</span> client;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    CSocket* m_socket;<br>    CSockParam m_param;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Client</span>(<span class="hljs-type">const</span> CSockParam&amp; param) : <span class="hljs-built_in">m_socket</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CSocket</span>()), <span class="hljs-built_in">m_param</span>(param) &#123;<br>        <span class="hljs-keyword">if</span> (m_socket-&gt;<span class="hljs-built_in">Init</span>(m_param) != <span class="hljs-number">0</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Client initialization failed.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Client</span>() &#123;<br>        <span class="hljs-keyword">delete</span> m_socket;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_socket-&gt;<span class="hljs-built_in">Link</span>() != <span class="hljs-number">0</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Client connection failed.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Client: Connection established.&quot;</span> &lt;&lt; std::endl;<br><br>        Buffer receivedData;<br>        <span class="hljs-keyword">if</span> (m_socket-&gt;<span class="hljs-built_in">Recv</span>(receivedData) == <span class="hljs-number">0</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Client: Failed to receive data.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Client: Received data: &quot;</span> &lt;&lt; receivedData &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    CSocket* m_socket;<br>    CSockParam m_param;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">CSockParam <span class="hljs-title">serverParam</span><span class="hljs-params">(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>, SOCK_ISSERVER | SOCK_ISIP | SOCK_ISREUSE)</span></span>;<br>    <span class="hljs-function">CSockParam <span class="hljs-title">clientParam</span><span class="hljs-params">(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>, SOCK_ISIP)</span></span>;<br><br>    <span class="hljs-function">Server <span class="hljs-title">server</span><span class="hljs-params">(serverParam)</span></span>;<br>    <span class="hljs-function">Client <span class="hljs-title">client</span><span class="hljs-params">(clientParam)</span></span>;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">serverThread</span><span class="hljs-params">(&amp;Server::Run, &amp;server)</span></span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)); <br>    client.<span class="hljs-built_in">Run</span>();<br><br>    serverThread.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="/image/image-20240802165440504.png" alt="image-20240802165440504"></p><h1 id="Socket-h完整代码"><a href="#Socket-h完整代码" class="headerlink" title="Socket.h完整代码"></a>Socket.h完整代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> Buffer = std::string;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SockAttr</span> &#123;<br>    SOCK_ISSERVER = <span class="hljs-number">1</span>,<br>    SOCK_ISNONBLOCK = <span class="hljs-number">2</span>,<br>    SOCK_ISUDP = <span class="hljs-number">4</span>,<br>    SOCK_ISIP = <span class="hljs-number">8</span>,<br>    SOCK_ISREUSE = <span class="hljs-number">16</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSockParam</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSockParam</span>()<br>        : <span class="hljs-built_in">port</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">attr</span>(<span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-built_in">bzero</span>(&amp;addr_in, <span class="hljs-built_in">sizeof</span>(addr_in));<br>        <span class="hljs-built_in">bzero</span>(&amp;addr_un, <span class="hljs-built_in">sizeof</span>(addr_un));<br>    &#125;<br><br>    <span class="hljs-built_in">CSockParam</span>(<span class="hljs-type">const</span> Buffer&amp; ip, <span class="hljs-type">short</span> port, <span class="hljs-type">int</span> attr)<br>        : <span class="hljs-built_in">ip</span>(ip), <span class="hljs-built_in">port</span>(port), <span class="hljs-built_in">attr</span>(attr) &#123;<br>        addr_in.sin_family = AF_INET;<br>        addr_in.sin_port = <span class="hljs-built_in">htons</span>(port);<br>        addr_in.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(ip.<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-built_in">CSockParam</span>(<span class="hljs-type">const</span> sockaddr_in* addrin, <span class="hljs-type">int</span> attr)<br>        : <span class="hljs-built_in">ip</span>(ip), <span class="hljs-built_in">port</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">attr</span>(attr) &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;addr_in, addrin, <span class="hljs-built_in">sizeof</span>(addr_in));<br>    &#125;<br><br>    <span class="hljs-built_in">CSockParam</span>(<span class="hljs-type">const</span> Buffer&amp; path, <span class="hljs-type">int</span> attr)<br>        : <span class="hljs-built_in">ip</span>(path), <span class="hljs-built_in">port</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">attr</span>(attr) &#123;<br>        addr_un.sun_family = AF_UNIX;<br>        <span class="hljs-built_in">strncpy</span>(addr_un.sun_path, path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(addr_un.sun_path) - <span class="hljs-number">1</span>); <br>    &#125;<br><br>    <span class="hljs-built_in">CSockParam</span>(<span class="hljs-type">const</span> CSockParam&amp; param)<br>        : <span class="hljs-built_in">ip</span>(param.ip), <span class="hljs-built_in">port</span>(param.port), <span class="hljs-built_in">attr</span>(param.attr) &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;addr_in, &amp;param.addr_in, <span class="hljs-built_in">sizeof</span>(addr_in));<br>        <span class="hljs-built_in">memcpy</span>(&amp;addr_un, &amp;param.addr_un, <span class="hljs-built_in">sizeof</span>(addr_un));<br>    &#125;<br><br>    CSockParam&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CSockParam&amp; param) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;param) &#123;<br>            ip = param.ip;<br>            port = param.port;<br>            attr = param.attr;<br>            <span class="hljs-built_in">memcpy</span>(&amp;addr_in, &amp;param.addr_in, <span class="hljs-built_in">sizeof</span>(addr_in));<br>            <span class="hljs-built_in">memcpy</span>(&amp;addr_un, &amp;param.addr_un, <span class="hljs-built_in">sizeof</span>(addr_un));<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function">sockaddr* <span class="hljs-title">addrin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr_in); &#125;<br>    <span class="hljs-function">sockaddr* <span class="hljs-title">addrun</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr_un); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> sockaddr* <span class="hljs-title">addrin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> sockaddr*&gt;(&amp;addr_in); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> sockaddr* <span class="hljs-title">addrun</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> sockaddr*&gt;(&amp;addr_un); &#125;<br><br><br><span class="hljs-keyword">public</span>:<br>    sockaddr_in addr_in;  <span class="hljs-comment">//网络套接字地址</span><br>    sockaddr_un addr_un;  <span class="hljs-comment">//本地套接字地址</span><br>    Buffer ip;<br>    <span class="hljs-type">short</span> port;<br>    <span class="hljs-type">int</span> attr;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSocketBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSocketBase</span>() : <span class="hljs-built_in">m_socket</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">m_status</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CSocketBase</span>() &#123;<br>        <span class="hljs-built_in">Close</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> CSockParam&amp; param)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Link</span><span class="hljs-params">(CSocketBase** pClient = <span class="hljs-literal">nullptr</span>)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">const</span> Buffer&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Recv</span><span class="hljs-params">(Buffer&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_socket; &#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-type">const</span> sockaddr_in*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> &amp;m_param.addr_in; &#125;<br>    <span class="hljs-keyword">operator</span> sockaddr_in*() &#123; <span class="hljs-keyword">return</span> &amp;m_param.addr_in; &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_socket;<br>    <span class="hljs-type">int</span> m_status;  <span class="hljs-comment">//0初始化未完成 1初始化完成 2连接完成 3已经关闭</span><br>    CSockParam m_param;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CSocketBase::Close</span><span class="hljs-params">()</span> </span>&#123;<br>    m_status = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (m_socket != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((m_param.attr &amp; SOCK_ISSERVER) &amp;&amp; !(m_param.attr &amp; SOCK_ISIP)) &#123;<br>            <span class="hljs-built_in">unlink</span>(m_param.ip.<span class="hljs-built_in">c_str</span>()); <br>        &#125;<br>        <span class="hljs-type">int</span> fd = m_socket;<br>        m_socket = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">close</span>(fd);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSocket</span> : <span class="hljs-keyword">public</span> CSocketBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSocket</span>() : <span class="hljs-built_in">m_socket</span>(<span class="hljs-number">-1</span>) &#123;&#125; <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CSocket</span><span class="hljs-params">(<span class="hljs-type">int</span> sock)</span> : m_socket(sock) &#123;</span>&#125; <br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CSocket</span>() &#123;<br>        <span class="hljs-built_in">Close</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> CSockParam&amp; param)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Link</span><span class="hljs-params">(CSocketBase** pClient = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">const</span> Buffer&amp; data)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Recv</span><span class="hljs-params">(Buffer&amp; data)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EnsureSocketInitialized</span><span class="hljs-params">(<span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SetupSocketOptions</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BindAndListen</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ConnectToAddress</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-function">std::unique_ptr&lt;CSocket&gt; <span class="hljs-title">AcceptConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span></span>;<br>    <span class="hljs-type">int</span> m_socket; <br>&#125;;<br><br><span class="hljs-comment">// 对于服务端： 执行socket，bind，listen  客户端：创建socket</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CSocket::Init</span><span class="hljs-params">(<span class="hljs-type">const</span> CSockParam&amp; param)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m_status != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">EnsureSocketInitialized</span>(param);<br>    <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; std::endl;</span><br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">SetupSocketOptions</span>(m_socket, param);<br>    <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; ret &lt;&lt; std::endl;</span><br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ret;<br><br>    <span class="hljs-keyword">if</span> (param.attr &amp; SOCK_ISSERVER) &#123;<br>        ret = <span class="hljs-built_in">BindAndListen</span>(m_socket, param);<br>        <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; ret &lt;&lt; std::endl;</span><br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ret;<br>    &#125; <br>    <span class="hljs-keyword">if</span>(m_status == <span class="hljs-number">0</span>)<br>        m_status = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CSocket::Link</span><span class="hljs-params">(CSocketBase** pClient)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m_status &lt;= <span class="hljs-number">0</span> || m_socket == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (m_param.attr &amp; SOCK_ISSERVER) &#123;<br>        <span class="hljs-keyword">if</span> (!pClient) <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>        <span class="hljs-keyword">auto</span> client = <span class="hljs-built_in">AcceptConnection</span>(m_socket, m_param);<br>        <span class="hljs-keyword">if</span> (!client) <span class="hljs-keyword">return</span> <span class="hljs-number">-3</span>;<br>        *pClient = client.<span class="hljs-built_in">release</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ConnectToAddress</span>(m_socket, m_param) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>;<br>        <br>    &#125;<br>    m_status = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CSocket::Send</span><span class="hljs-params">(<span class="hljs-type">const</span> Buffer&amp; data)</span> </span>&#123;<br>    <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; m_status &lt;&lt; &quot; &quot; &lt;&lt;  m_socket &lt;&lt; std::endl;</span><br>    <span class="hljs-keyword">if</span> (m_status &lt; <span class="hljs-number">2</span> || m_socket == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-type">ssize_t</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">ssize_t</span>&gt;(data.<span class="hljs-built_in">size</span>())) &#123;<br>        <span class="hljs-type">ssize_t</span> len = <span class="hljs-built_in">write</span>(m_socket, data.<span class="hljs-built_in">data</span>() + index, data.<span class="hljs-built_in">size</span>() - index);<br>        <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; len &lt;&lt; std::endl;</span><br>        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> len &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-3</span> : <span class="hljs-number">-2</span>;<br>        index += len;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CSocket::Recv</span><span class="hljs-params">(Buffer&amp; data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m_status &lt; <span class="hljs-number">2</span> || m_socket == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; m_status &lt;&lt; &quot; &quot; &lt;&lt; m_socket &lt;&lt; std::endl;</span><br>    data.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>    <span class="hljs-type">ssize_t</span> len = <span class="hljs-built_in">read</span>(m_socket, <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(data.<span class="hljs-built_in">data</span>()), data.<span class="hljs-built_in">size</span>()); <br>    <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; len &lt;&lt; std::endl;</span><br>    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>        data.<span class="hljs-built_in">resize</span>(len);<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>    data.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (errno == EINTR || errno == EAGAIN) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSocket::EnsureSocketInitialized</span><span class="hljs-params">(<span class="hljs-type">const</span> CSockParam&amp; param)</span> </span>&#123;<br>    m_param = param;<br>    <span class="hljs-type">int</span> type = (param.attr &amp; SOCK_ISUDP) ? SOCK_DGRAM : SOCK_STREAM;<br>    <span class="hljs-keyword">if</span> (m_socket == <span class="hljs-number">-1</span>) &#123;<br>        m_socket = (param.attr &amp; SOCK_ISIP) ? <span class="hljs-built_in">socket</span>(PF_INET, type, <span class="hljs-number">0</span>)<br>                                            : <span class="hljs-built_in">socket</span>(PF_LOCAL, type, <span class="hljs-number">0</span>);<br>    &#125;<br>    m_status = <span class="hljs-number">2</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CSocket::SetupSocketOptions</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (socketFd == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><br>    <span class="hljs-keyword">if</span> (param.attr &amp; SOCK_ISREUSE) &#123;<br>        <span class="hljs-type">int</span> option = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(socketFd, SOL_SOCKET, SO_REUSEADDR, &amp;option, <span class="hljs-built_in">sizeof</span>(option)) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-7</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (param.attr &amp; SOCK_ISNONBLOCK) &#123;<br>        <span class="hljs-type">int</span> option = <span class="hljs-built_in">fcntl</span>(socketFd, F_GETFL);<br>        <span class="hljs-keyword">if</span> (option == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-5</span>;<br>        option |= O_NONBLOCK;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(socketFd, F_SETFL, option) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-6</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CSocket::BindAndListen</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (param.attr &amp; SOCK_ISIP) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(socketFd, param.<span class="hljs-built_in">addrin</span>(), <span class="hljs-built_in">sizeof</span>(sockaddr_in)) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-3</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(socketFd, param.<span class="hljs-built_in">addrun</span>(), <span class="hljs-built_in">sizeof</span>(sockaddr_un)) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-3</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(socketFd, <span class="hljs-number">32</span>) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CSocket::ConnectToAddress</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (param.attr &amp; SOCK_ISIP) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(socketFd, param.<span class="hljs-built_in">addrin</span>(), <span class="hljs-built_in">sizeof</span>(sockaddr_in)) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-6</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(socketFd, param.<span class="hljs-built_in">addrun</span>(), <span class="hljs-built_in">sizeof</span>(sockaddr_un)) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-6</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">std::unique_ptr&lt;CSocket&gt; <span class="hljs-title">CSocket::AcceptConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> socketFd, <span class="hljs-type">const</span> CSockParam&amp; param)</span> </span>&#123;<br>    CSockParam clientParam;<br>    <span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (param.attr &amp; SOCK_ISIP) &#123;<br>        len = <span class="hljs-built_in">sizeof</span>(sockaddr_in);<br>        fd = <span class="hljs-built_in">accept</span>(socketFd, clientParam.<span class="hljs-built_in">addrin</span>(), &amp;len);<br>        <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;ISIP: &quot; &lt;&lt; fd &lt;&lt; std::endl;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        len = <span class="hljs-built_in">sizeof</span>(sockaddr_un);<br>        fd = <span class="hljs-built_in">accept</span>(socketFd, clientParam.<span class="hljs-built_in">addrun</span>(), &amp;len);<br>        <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;本地套接字: &quot; &lt;&lt; fd &lt;&lt; std::endl;</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    clientParam.attr |= SOCK_ISIP;<br>    <span class="hljs-keyword">auto</span> client = std::<span class="hljs-built_in">unique_ptr</span>&lt;CSocket&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CSocket</span>(fd)); <br>    <span class="hljs-type">int</span> ret = client-&gt;<span class="hljs-built_in">Init</span>(clientParam);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;accept client init fault !! &quot; &lt;&lt; ret &lt;&lt; std::endl;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> client;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地套接字与网络套接字的区别和用法</title>
    <link href="/2024/07/31/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/"/>
    <url>/2024/07/31/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>网络套接字</strong>是通过<strong>绑定ip和端口</strong>使网络中的进程之间进行通信，而<strong>本地套接字****是绑定套接字文件的路径名来使单机中的进程间通信</strong>,是一种IPC机制,其存储地址结构的数据类型为<code>struct sockaddr_un</code>,该数据类型包含在<code>#include&lt;sys/un.h&gt;</code>头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_un</span> &#123;<br><span class="hljs-type">sa_family_t</span> sun_family; <span class="hljs-comment">/*PF_UNIX或AF_UNIX */</span><br><span class="hljs-type">char</span> sun_path[UNIX_PATH_MAX]; <span class="hljs-comment">/* 路径名 */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>网络套接字客户端可以隐式绑定ip和端口，但是<strong>本地套接字客户端必须绑定套接字文件的路径名</strong>，否则无法通信(因为本地套接字通信模式中bind函数会创建套接字文件，两个进程之间的通信是通过各自的套接字文件来进行的)</p></li></ol><p>其他的跟网络套接字使用一样</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unix/Linux系统中的`fork()`系统调用</title>
    <link href="/2024/07/31/Unix-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2024/07/31/Unix-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>使用Unix&#x2F;Linux系统中的<code>fork()</code>系统调用时，需要注意的线程与进程之间的关系</p><ol><li><strong>线程无法被复制</strong>：<code>fork()</code>发生时，只有调用<code>fork()</code>的那个线程会被复制到子进程中，其他的线程不会被复制过去。如果父进程中某个线程负责资源的初始化或清理，而在子进程中这个线程不存在，那么可能会导致资源未被正确管理，进而引发错误。</li><li><strong>先准备好进程结构，再去使用线程</strong>：涉及<code>fork()</code>和多线程的程序时，应该先明确进程的创建和初始化过程，确保在创建新的线程之前，进程的结构已经稳定。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOCP异步编程</title>
    <link href="/2024/07/26/IOCP%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/07/26/IOCP%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="iocp异步编程流程"><a href="#iocp异步编程流程" class="headerlink" title="iocp异步编程流程"></a>iocp异步编程流程</h1><ol><li><p><strong>创建I&#x2F;O完成端口</strong>: 使用<code>CreateIoCompletionPort</code>函数创建一个I&#x2F;O完成端口。这个端口将作为异步操作完成时的通知中心，需要与套接字关联。</p><blockquote><p><code>HANDLE CreateIoCompletionPort(  HANDLE FileHandle,  HANDLE ExistingCompletionPort,  ULONG_PTR CompletionKey,  DWORD NumberOfConcurrentThreads );</code></p><ol><li><strong>FileHandle</strong>：要与新创建或已存在的I&#x2F;O完成端口关联的文件句柄。首次创建IOCP传入<code>INVALID_HANDLE_VALUE</code>，表示仅创建一个空的I&#x2F;O完成端口。</li><li><strong>ExistingCompletionPort</strong>：一个已存在的I&#x2F;O完成端口句柄。如果想将<code>FileHandle</code>关联到这个已存在的I&#x2F;O完成端口上，就提供这个句柄；如果是要创建一个新的I&#x2F;O完成端口，则此参数应为<code>NULL</code>。</li><li><strong>CompletionKey</strong>：一个无符号长整数，由应用程序提供，作为完成键（Completion Key）。当一个I&#x2F;O操作完成时，这个键会随着完成通知一起返回给应用程序，用于标识完成的I&#x2F;O操作或与之关联的上下文。</li><li><strong>NumberOfConcurrentThreads</strong>：指定工作线程池中可以同时运行的线程的最大数目。如果设置为0，则系统将自动调整线程数量以达到最佳性能。通常，合理的线程数取决于系统的CPU核心数和I&#x2F;O负载。</li></ol><p>具体：<code>m_HIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 4);</code></p><ul><li>成功时，返回新创建或已关联的I&#x2F;O完成端口的句柄。</li><li>失败时，返回<code>NULL</code>，并可通过<code>GetLastError</code>获取错误码。</li></ul></blockquote></li><li><p><strong>创建并配置套接字</strong>: 使用<code>WSASocket</code>函数创建一个或多个套接字，并设置为使用重叠I&#x2F;O模型（通过<code>WSA_FLAG_OVERLAPPED</code>标志），允许套接字进行异步操作。</p><blockquote><p>具体：<code>m_servSocket = WSASocket(PF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);</code></p><ul><li><strong>af</strong>：地址族，如<code>AF_INET</code>用于IPv4或<code>AF_INET6</code>用于IPv6。</li><li><strong>type</strong>：套接字类型，如<code>SOCK_STREAM</code>用于TCP连接，<code>SOCK_DGRAM</code>用于UDP数据报。</li><li><strong>protocol</strong>：指定协议，通常为0，让系统根据<code>af</code>和<code>type</code>自动选择。</li><li><strong>lpProtocolInfo</strong>：指向一个<code>WSAPROTOCOL_INFO</code>结构的指针，允许直接指定协议信息，提供更细粒度的控制。</li><li><strong>g</strong>：保留，通常传入0。</li><li><strong>dwFlags</strong>：标志位，如<code>WSA_FLAG_OVERLAPPED</code>表示创建支持重叠I&#x2F;O的套接字，这对于使用IOCP模型是必需的。</li></ul></blockquote></li><li><p><strong>绑定套接字到I&#x2F;O完成端口</strong>: 再次使用<code>CreateIoCompletionPort</code>函数将每个套接字与之前创建的I&#x2F;O完成端口关联。这一步确保与这些套接字相关的I&#x2F;O操作完成时，通知将被发送到I&#x2F;O完成端口。</p><blockquote><p>具体：<code>CreateIoCompletionPort((HANDLE)m_servSocket, m_HIOCP, 0, 0)</code></p><ul><li><strong>m_servSocket</strong>：要关联的套接字；</li><li><strong>m_HIOCP</strong>：创建的完成端口</li></ul></blockquote></li><li><p><strong>初始化OVERLAPPED结构</strong>: 对于每个异步操作（如<code>ConnectEx</code>, <code>ReadFile</code>, <code>WriteFile</code>, <code>WSARecv</code>, <code>WSASend</code>等），都需要创建并初始化一个或多个<code>OVERLAPPED</code>结构（或其派生类），这个结构包含了操作的状态信息和完成时的回调参数。这里除了原始的OVERLAPPED，还包括连接的其他重要参数信息</p><blockquote><p><code>CMClient* pClient = new CMClient(this,m_HIOCP);</code></p></blockquote></li><li><p><strong>启动监听或连接操作</strong>: 根据需要，使用如<code>bind</code>, <code>listen</code>, <code>AcceptEx</code>等函数开始监听网络连接。对于客户端，可能直接使用<code>ConnectEx</code>进行异步连接。</p><blockquote><pre><code class="hljs">            AcceptEx(m_servSocket, pClient-&gt;m_clntSocket,                pClient-&gt;m_accept-&gt;m_buffer.data(),0,                sizeof(sockaddr_in) + 16,sizeof(sockaddr_in) + 16,                &amp;pClient-&gt;m_accept-&gt;m_received,&amp;pClient-&gt;m_accept-&gt;m_overlapped);</code></pre></blockquote></li><li><p><strong>发起异步I&#x2F;O操作</strong>: 当准备读取或写入数据时，使用相应的异步函数，如<code>WSARecv</code>和<code>WSASend</code>，并将之前准备好的<code>OVERLAPPED</code>结构传递给这些函数。<strong>这些操作会立即返回，而不会等待I&#x2F;O完成</strong>。</p></li><li><p><strong>等待并处理I&#x2F;O完成通知</strong>: 在主线程或一个专用的工作线程中，使用<code>GetQueuedCompletionStatus</code>循环等待I&#x2F;O完成的通知。当一个I&#x2F;O操作完成时，这些函数会返回，并提供完成键、传输的字节数、以及指向关联的<code>OVERLAPPED</code>结构的指针。</p><blockquote><p>取出<code>OVERLAPPED</code>结构的指针进行下一步的处理，这里可以把指针转换为一个结构体，涉及到类的下行转换，虽然说理论上是不安全的，但是这里也没有使用dynamic_cast进行强制类型转换，因为传进去的时候其实就是一个派生类的m_overlapped成员变量，自己知道这个下行转换是安全的</p></blockquote></li><li><p><strong>根据完成键和OVERLAPPED结构处理操作结果</strong>: 根据<code>OVERLAPPED</code>结构中的信息，确定操作类型（如读、写、接受连接等）并执行相应的后续处理。这可能包括数据处理、错误处理、再次发起读写操作等。然后就循环新连接，接受发送，然后等待异步处理</p></li></ol><p><strong>这里要注意的是如果是处理了一个新连接的时候要重新创建一个客户端socket然后与io完成端口绑定，才能接受新的连接</strong></p><h1 id="AcceptEx函数以及与accept函数的区别"><a href="#AcceptEx函数以及与accept函数的区别" class="headerlink" title="AcceptEx函数以及与accept函数的区别"></a>AcceptEx函数以及与accept函数的区别</h1><p><code>AcceptEx</code>函数是Winsock2 扩展API的一部分，专用于Windows平台，用于异步接受TCP连接请求。它相比传统的<code>accept</code>函数提供了更多的功能和灵活性。</p><h2 id="AcceptEx-函数介绍"><a href="#AcceptEx-函数介绍" class="headerlink" title="AcceptEx 函数介绍"></a>AcceptEx 函数介绍</h2><ul><li><strong>功能</strong>：<code>AcceptEx</code>函数允许服务器端在同一个调用中完成接受连接请求和接收连接套接字的<strong>初始化工作</strong>，同时还能<strong>从连接请求中提取客户端地址信息</strong>。它支持重叠I&#x2F;O模型，因此可以与I&#x2F;O完成端口（IOCP）结合，实现高效的异步接受处理。</li><li><strong>参数</strong>：<code>AcceptEx</code>接受多个参数，包括监听套接字、新的接受套接字（预先创建）、用于存储连接数据的缓冲区、缓冲区偏移量以及指向接收缓冲区大小和接收的地址信息的指针。它还接受一个<code>OVERLAPPED</code>结构的指针，用于异步操作的完成通知。</li><li><strong>缓冲区共享</strong>：<code>AcceptEx</code>使用一个共享的缓冲区来<strong>同时接收连接请求数据和客户端地址信息</strong>，这有助于减少系统调用和内存分配，提高效率。</li></ul><h2 id="与accept的区别"><a href="#与accept的区别" class="headerlink" title="与accept的区别"></a>与accept的区别</h2><ol><li><strong>异步支持</strong>：<code>accept</code>函数在默认情况下是<strong>阻塞</strong>的，即调用它时，如果没有新的连接请求到达，调用线程会被阻塞，直到连接请求到来。而<code>AcceptEx</code>设计用于异步操作，结合重叠I&#x2F;O和I&#x2F;O完成端口，可以避免阻塞，提高服务器的响应性和处理能力。</li><li><strong>连接初始化</strong>：<code>accept</code>函数接受连接后会返回一个新的套接字，而这个新套接字需要进一步的配置，如设置为非阻塞模式、绑定、设置选项等。<code>AcceptEx</code>则允许在函数调用时直接指定并初始化这个新套接字，减少了额外的配置步骤。</li><li><strong>数据接收</strong>：<code>AcceptEx</code>在接受连接的同时，可以读取连接请求的初始数据，<code>accept</code>不能。</li><li><strong>缓冲区管理</strong>：如前所述，<code>AcceptEx</code>使用共享缓冲区来存储连接数据和地址信息，而<code>accept</code>不涉及缓冲区管理，只负责接受连接。</li><li><strong>平台特定</strong>：<code>AcceptEx</code>是Windows特有的，而<code>accept</code>则是POSIX标准的一部分，跨平台兼容性更好。</li></ol><h1 id="设置重叠io的技巧"><a href="#设置重叠io的技巧" class="headerlink" title="设置重叠io的技巧"></a>设置重叠io的技巧</h1><p>​重叠io是关联了一个客户端连接的，具体的可以关联到一个客户端的某个操作，包括发送、接受、创建和关闭，也就是说重叠io是跟某一个客户端关联的，所以我们可以在重叠io这里设置了一个类，类里面的第一个成员变量是重叠io，后面的成员变量客户端连接的状态信息，包括客户端连接的上下文信息，I&#x2F;O操作类型，实际接受到的字节数，数据缓冲区这些信息。这样的话，在收到完成端口传出来的重叠io的时候就可以进行类型转换，然后得到这个客户端连接的状态信息。</p><p>​对于不同操作对应的重叠io，可以把它设置为一个重叠io的派生类，包括发送，接受，创建，关闭这四个派生类，派生类里面的关键是一个回调函数，每个操作都会有一个回调函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践 windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池类设计</title>
    <link href="/2024/07/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/07/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>1 <strong>首先要先封装线程类</strong>。</p><p>2 <strong>然后设计线程池类</strong>。</p><p>3 <strong>设计任务类</strong>。</p><p>4 <strong>最后整合三个模块</strong>，一个最原始的线程池就完成了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>va_list的用法</title>
    <link href="/2024/07/21/va-list%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2024/07/21/va-list%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="VA-LIST的用法："><a href="#VA-LIST的用法：" class="headerlink" title="VA_LIST的用法："></a>VA_LIST的用法：</h1><ol><li><p>首先在函数里定义一具VA_LIST型的变量，这个变量是指向参数的指针； </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">va_list args<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>然后用VA_START宏初始化变量刚定义的VA_LIST变量； </p><p>使用<code>va_start</code>宏初始化<code>va_list</code>变量。<code>va_start</code>需要两个参数：<code>va_list</code>变量和最后一个固定参数（在…之前的参数）的地址。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">void my_printf(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">format</span>, ...) &#123;<br>    va_list <span class="hljs-keyword">args</span>;<br>    va_start(<span class="hljs-keyword">args</span>, <span class="hljs-keyword">format</span>); <span class="hljs-comment">// 注意：format是位于...之前的最后一个已知参数</span><br>    <span class="hljs-comment">// 接下来可以使用args访问可变参数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后用VA_ARG返回可变的参数，VA_ARG的第二个参数是你要返回的参数的类型（如果函数有多个可变参数的，依次调用VA_ARG获取各个参数）；</p><p><code>va_arg</code>需要两个参数：第一个是<code>va_list</code>变量，第二个是要获取的参数类型。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> arg_int = va_arg(args, <span class="hljs-keyword">int</span>); <span class="hljs-regexp">//</span> 获取一个<span class="hljs-keyword">int</span>类型的参数<br></code></pre></td></tr></table></figure></li><li><p>最后用VA_END宏结束可变参数的获取，清理操作，通常放在函数的末尾。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">va_end</span>(args);<br></code></pre></td></tr></table></figure></li></ol><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino">LogInfo::<span class="hljs-built_in">LogInfo</span>(<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">int</span> line, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* func,<br><span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">int</span> level,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...<br>)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> sLevel[][<span class="hljs-number">8</span>] = &#123;<br><span class="hljs-string">&quot;INFO&quot;</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>,<span class="hljs-string">&quot;WARNING&quot;</span>,<span class="hljs-string">&quot;ERROR&quot;</span>,<span class="hljs-string">&quot;FATAL&quot;</span><br>&#125;;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">NULL</span>;<br>bAuto = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//日志前缀</span><br><span class="hljs-type">int</span> count = <span class="hljs-built_in">asprintf</span>(&amp;buf, <span class="hljs-string">&quot;%s(%d):[%s][%s]&lt;%d-%d&gt;(%s) &quot;</span>,<br>file, line, sLevel[level],<br>(<span class="hljs-type">char</span>*)CLoggerServer::<span class="hljs-built_in">GetTimeStr</span>(), pid, tid, func);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf = buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//日志变参部分</span><br>va_list ap;<br><span class="hljs-built_in">va_start</span>(ap, fmt);<br>count = <span class="hljs-built_in">vasprintf</span>(&amp;buf, fmt, ap);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf += buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-built_in">va_end</span>(ap);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="额外知识："><a href="#额外知识：" class="headerlink" title="额外知识："></a>额外知识：</h2><p><code>vasprintf</code>是一个高级的变体，它结合了<code>vprintf</code>的功能（使用<code>va_list</code>参数列表格式化输出）和<code>asprintf</code>的能力（自动分配所需的缓冲区来存放结果字符串）。</p><p><code>asprintf</code>和<code>vsprintf</code>都是C语言中用于格式化输出字符串到动态分配的内存或预定义缓冲区的函数，它们都是<code>printf</code>系列函数的变体，主要用于处理可变参数列表。</p><h3 id="vsprintf"><a href="#vsprintf" class="headerlink" title="vsprintf"></a>vsprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, va_list arg)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>:</p><p><code>vsprintf</code>函数将<code>format</code>字符串中指定的格式化字符串写入到由<code>str</code>指向的缓冲区中。与<code>sprintf</code>类似，但它不是直接接受可变参数，而是通过一个<code>va_list</code>（由<code>va_start</code>初始化）来访问参数列表。</p><p><strong>参数</strong>:</p><ul><li><code>str</code>: 目标缓冲区的指针，必须足够大以容纳格式化后的字符串，否则会导致缓冲区溢出。</li><li><code>format</code>: 控制定制字符串格式的格式字符串，由普通文本和特殊的格式占位符组成，这些占位符指示如何处理并插入相应的参数值</li><li><code>arg</code>: 一个之前由<code>va_start</code>初始化的<code>va_list</code>，用于访问可变参数列表。</li></ul><h3 id="asprintf"><a href="#asprintf" class="headerlink" title="asprintf"></a>asprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">asprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> **strp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>: <code>asprintf</code>函数类似于<code>vsprintf</code>，但更加方便和安全，因为它会自动为格式化后的字符串分配内存，并通过<code>strp</code>返回指向这块内存的指针，<strong>调用者无需预先分配或担心缓冲区溢出问题</strong>。</p><p><strong>特点</strong>:</p><ul><li><code>asprintf</code>自动管理内存分配，改变指针指向</li><li>第三个参数是可变参数，而不是预先初始化好的可变参数列表va_list。</li></ul><p><strong>注意事项</strong>:</p><ul><li>动态分配的内存需要通过<code>free</code>手动释放，以防止内存泄漏。</li></ul><h3 id="vasprintf"><a href="#vasprintf" class="headerlink" title="vasprintf"></a>vasprintf</h3><p><code>vasprintf</code>会根据<code>fmt</code>和<code>ap</code>中的参数<strong>自动格式化字符串</strong>，并动态分配内存给结果字符串，然后修改了传入的<code>buf</code>（一个指针）的值，使其指向新分配的、包含格式化后字符串的内存区域，之后可以直接通过<code>buf</code>访问到这个新创建的字符串</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
