<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>va_list的用法</title>
    <link href="/title/"/>
    <url>/title/</url>
    
    <content type="html"><![CDATA[<h1 id="VA-LIST的用法："><a href="#VA-LIST的用法：" class="headerlink" title="VA_LIST的用法："></a>VA_LIST的用法：</h1><ol><li><p>首先在函数里定义一具VA_LIST型的变量，这个变量是指向参数的指针； </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">va_list args<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>然后用VA_START宏初始化变量刚定义的VA_LIST变量； </p><p>使用<code>va_start</code>宏初始化<code>va_list</code>变量。<code>va_start</code>需要两个参数：<code>va_list</code>变量和最后一个固定参数（在…之前的参数）的地址。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">void my_printf(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">format</span>, ...) &#123;<br>    va_list <span class="hljs-keyword">args</span>;<br>    va_start(<span class="hljs-keyword">args</span>, <span class="hljs-keyword">format</span>); <span class="hljs-comment">// 注意：format是位于...之前的最后一个已知参数</span><br>    <span class="hljs-comment">// 接下来可以使用args访问可变参数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后用VA_ARG返回可变的参数，VA_ARG的第二个参数是你要返回的参数的类型（如果函数有多个可变参数的，依次调用VA_ARG获取各个参数）；</p><p><code>va_arg</code>需要两个参数：第一个是<code>va_list</code>变量，第二个是要获取的参数类型。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> arg_int = va_arg(args, <span class="hljs-keyword">int</span>); <span class="hljs-regexp">//</span> 获取一个<span class="hljs-keyword">int</span>类型的参数<br></code></pre></td></tr></table></figure></li><li><p>最后用VA_END宏结束可变参数的获取，清理操作，通常放在函数的末尾。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">va_end</span>(args);<br></code></pre></td></tr></table></figure></li></ol><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino">LogInfo::<span class="hljs-built_in">LogInfo</span>(<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">int</span> line, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* func,<br><span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">int</span> level,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...<br>)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> sLevel[][<span class="hljs-number">8</span>] = &#123;<br><span class="hljs-string">&quot;INFO&quot;</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>,<span class="hljs-string">&quot;WARNING&quot;</span>,<span class="hljs-string">&quot;ERROR&quot;</span>,<span class="hljs-string">&quot;FATAL&quot;</span><br>&#125;;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">NULL</span>;<br>bAuto = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//日志前缀</span><br><span class="hljs-type">int</span> count = <span class="hljs-built_in">asprintf</span>(&amp;buf, <span class="hljs-string">&quot;%s(%d):[%s][%s]&lt;%d-%d&gt;(%s) &quot;</span>,<br>file, line, sLevel[level],<br>(<span class="hljs-type">char</span>*)CLoggerServer::<span class="hljs-built_in">GetTimeStr</span>(), pid, tid, func);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf = buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//日志变参部分</span><br>va_list ap;<br><span class="hljs-built_in">va_start</span>(ap, fmt);<br>count = <span class="hljs-built_in">vasprintf</span>(&amp;buf, fmt, ap);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf += buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-built_in">va_end</span>(ap);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="额外知识："><a href="#额外知识：" class="headerlink" title="额外知识："></a>额外知识：</h2><p><code>vasprintf</code>是一个高级的变体，它结合了<code>vprintf</code>的功能（使用<code>va_list</code>参数列表格式化输出）和<code>asprintf</code>的能力（自动分配所需的缓冲区来存放结果字符串）。</p><p><code>asprintf</code>和<code>vsprintf</code>都是C语言中用于格式化输出字符串到动态分配的内存或预定义缓冲区的函数，它们都是<code>printf</code>系列函数的变体，主要用于处理可变参数列表。</p><h3 id="vsprintf"><a href="#vsprintf" class="headerlink" title="vsprintf"></a>vsprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, va_list arg)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>:</p><p><code>vsprintf</code>函数将<code>format</code>字符串中指定的格式化字符串写入到由<code>str</code>指向的缓冲区中。与<code>sprintf</code>类似，但它不是直接接受可变参数，而是通过一个<code>va_list</code>（由<code>va_start</code>初始化）来访问参数列表。</p><p><strong>参数</strong>:</p><ul><li><code>str</code>: 目标缓冲区的指针，必须足够大以容纳格式化后的字符串，否则会导致缓冲区溢出。</li><li><code>format</code>: 控制定制字符串格式的格式字符串，由普通文本和特殊的格式占位符组成，这些占位符指示如何处理并插入相应的参数值</li><li><code>arg</code>: 一个之前由<code>va_start</code>初始化的<code>va_list</code>，用于访问可变参数列表。</li></ul><h3 id="asprintf"><a href="#asprintf" class="headerlink" title="asprintf"></a>asprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">asprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> **strp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>: <code>asprintf</code>函数类似于<code>vsprintf</code>，但更加方便和安全，因为它会自动为格式化后的字符串分配内存，并通过<code>strp</code>返回指向这块内存的指针，<strong>调用者无需预先分配或担心缓冲区溢出问题</strong>。</p><p><strong>特点</strong>:</p><ul><li><code>asprintf</code>自动管理内存分配，改变指针指向</li><li>第三个参数是可变参数，而不是预先初始化好的可变参数列表va_list。</li></ul><p><strong>注意事项</strong>:</p><ul><li>动态分配的内存需要通过<code>free</code>手动释放，以防止内存泄漏。</li></ul><h3 id="vasprintf"><a href="#vasprintf" class="headerlink" title="vasprintf"></a>vasprintf</h3><p><code>vasprintf</code>会根据<code>fmt</code>和<code>ap</code>中的参数<strong>自动格式化字符串</strong>，并动态分配内存给结果字符串，然后修改了传入的<code>buf</code>（一个指针）的值，使其指向新分配的、包含格式化后字符串的内存区域，之后可以直接通过<code>buf</code>访问到这个新创建的字符串</p>]]></content>
    
    
    
    <tags>
      
      <tag>语言技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
