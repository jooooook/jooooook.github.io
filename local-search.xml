<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>http-parser库的使用</title>
    <link href="/2024/07/31/http-parser%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/07/31/http-parser%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>http-parser库是C语言实现的，比较简单，仅仅支持HTTP&#x2F;1.0和HTTP&#x2F;1.1，支持边接收边解析，解析过程中可随时中断和恢复，比较轻量，每个连接仅需少量内存，既可以作为独立库集成到现有项目中，也可以作为构建自定义HTTP服务器的基础组件。</p><p>为了使用方便，需要进行封装</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>连不上云服务器mysql</title>
    <link href="/2024/07/31/%E8%BF%9E%E4%B8%8D%E4%B8%8A%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8mysql/"/>
    <url>/2024/07/31/%E8%BF%9E%E4%B8%8D%E4%B8%8A%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="连不上云服务器mysql"><a href="#连不上云服务器mysql" class="headerlink" title="连不上云服务器mysql"></a>连不上云服务器mysql</h1><p>原因：mysql只监听了本地回环地址，bind-address &#x3D; 127.0.0.1，可以使用<code>netstat -tulnp | grep mysql</code>命令查看是否是127.0.0.1，</p><p>解决步骤：</p><ol><li><p>打开MySQL配置文件。MySQL的配置文件通常位于<code>/etc/mysql/my.cnf</code>或者<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sudo nano <span class="hljs-string">/etc/mysql/mysql.conf.d/mysqld.cnf</span>  <br><br>*****<br>[mysqld]<br><span class="hljs-string">...</span><br>bind-address = 0.0.0.0    <span class="hljs-string">//</span>修改为这个后可以监听所有ip<br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>ctrl+x 按y保存后退出</p></li><li><p>重启mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart mysq<br></code></pre></td></tr></table></figure></li><li><p><code>netstat -tulnp | grep mysql</code>查看是否监听0.0.0.0</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>windows中使用socket</title>
    <link href="/2024/07/31/windows%E4%B8%AD%E4%BD%BF%E7%94%A8socket/"/>
    <url>/2024/07/31/windows%E4%B8%AD%E4%BD%BF%E7%94%A8socket/</url>
    
    <content type="html"><![CDATA[<h1 id="windows中使用socket前需要使用WSAStratup函数"><a href="#windows中使用socket前需要使用WSAStratup函数" class="headerlink" title="windows中使用socket前需要使用WSAStratup函数"></a>windows中使用socket前需要使用WSAStratup函数</h1><p><code>WSAStartup()</code>函数负责初始化Winsock DLL（动态链接库），它是Windows上实现Socket API的库。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">WSAData wsa;<br><span class="hljs-comment">//Winsock版本2.2</span><br><span class="hljs-comment">//1.1早期版本，功能不足，现在一般使用2.2</span><br><span class="hljs-built_in">WSAStartup</span>(MAKEWORD(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsa);  <br><span class="hljs-built_in">WSACleanup</span>();<br></code></pre></td></tr></table></figure><p><code>WSAStartup()</code>和<code>WSACleanup()</code>函数之间存在一种计数机制。每次调用<code>WSAStartup()</code>，都会增加一个计数器；而每次调用<code>WSACleanup()</code>，则会减少这个计数器。只有当计数器归零时，所有资源才会被释放，Winsock DLL才可能被卸载。这样设计是为了防止在应用程序的不同部分分别调用初始化和清理函数时可能出现的资源泄漏问题。</p><p><code>WSAStartup()</code>确保了Winsock DLL的线程安全特性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内存中的“cc”</title>
    <link href="/2024/07/31/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E2%80%9Ccc%E2%80%9D/"/>
    <url>/2024/07/31/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E2%80%9Ccc%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="内存中的“cc”"><a href="#内存中的“cc”" class="headerlink" title="内存中的“cc”"></a>内存中的“cc”</h1><p>代表的是十六进制数 <code>0xCC</code>，在汇编语言和低级编程中与 <code>int 3</code> 指令关联，当 CPU 遇到 <code>int 3</code> 指令时，它会触发一个异常，这通常被调试器捕获。</p><p>通常用于程序报错和调试，打断点的时候会有cc</p><p>未初始化的内存也有可能有cc，这个在调试模式下面可以告诉程序员这里出错了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>无法解析的外部命令问题</title>
    <link href="/2024/07/31/%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="无法解析的外部命令"><a href="#无法解析的外部命令" class="headerlink" title="无法解析的外部命令"></a>无法解析的外部命令</h1><p>1、有函数声明了但是没有实现</p><p>2、头文件A可能依赖于头文件B中的某个类型或声明。如果包含顺序颠倒，即先包含B后包含A，那么A中使用B中的类型或声明的部分可能在编译时找不到相应的定义，因为B还未被包含。</p><p>3、在C++中，如果一个头文件在命名空间外部定义了符号，而另一个头文件在命名空间内部定义了同名符号，那么包含顺序也可能导致链接错误，因为编译器可能无法正确解析这些符号的链接</p><h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__UuidCreate@4，函数 <span class="hljs-string">&quot;public: __thiscall RTSPSession::RTSPSession(class ESocket const &amp;)&quot;</span> (??<span class="hljs-number">0</span>RTSPSession@@QAE@ABVESocket@@@Z) 中引用了该符号<br></code></pre></td></tr></table></figure><p>缺库： <code>#pragma comment(lib, &quot;rpcrt4.lib&quot;)  </code></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__accept@12，函数 <span class="hljs-string">&quot;public: class ESocket __thiscall ESocket::Accept(class EAddress &amp;)&quot;</span> (?Accept@ESocket@@QAE?AV1@AAVEAddress@@@Z) 中引用了该符号<br><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__bind@12，函数 <span class="hljs-string">&quot;public: int __thiscall ESocket::Bind(class EAddress const &amp;)&quot;</span> (?Bind@ESocket@@QAEHABVEAddress@@@Z) 中引用了该符号<br><span class="hljs-number">1</span>&gt;RTSPServer.obj : <span class="hljs-keyword">error</span> LNK2019: 无法解析的外部符号 __imp__closesocket@4，函数 <span class="hljs-string">&quot;public: void __thiscall Socket::Close(void)&quot;</span> (?Close@Socket@@QAEXXZ) 中引用了该符号<br><span class="hljs-number">1</span>&gt;VideoRTSPServer.obj : <span class="hljs-keyword">error</span> LNK2001: 无法解析的外部符号 __imp__closesocket@4<br></code></pre></td></tr></table></figure><p>缺库：<code>#pragma comment(lib, &quot;ws2_32.lib&quot;) </code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>头文件循环引用和重定义问题</title>
    <link href="/2024/07/31/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/31/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="防止头文件循环引用"><a href="#防止头文件循环引用" class="headerlink" title="防止头文件循环引用"></a>防止头文件循环引用</h1><p>比如一个头文件a引用头文件b，头文件b需要引用头文件a，则需要在其中一个头文件中，比如在头文件b中使用a中类的声明，然后在b的cpp文件中使用a的头文件可以解决。</p><h1 id="头文件引发的重定义问题"><a href="#头文件引发的重定义问题" class="headerlink" title="头文件引发的重定义问题"></a>头文件引发的重定义问题</h1><p><strong>重定义产生的情况</strong></p><ul><li><p>情况一：<strong>多个源文件包含了同一个头文件时，如果头文件中有某个局部变量或者非内联函数的定义</strong>，那么相当于每个源文件都把该局部变量或者非内联函数定义了一次。而它们（局部变量或者非内联函数）在这种情况下默认又是全局的，那么自然会导致重定义错误。</p></li><li><p>情况二：某个源文件多次包含同一个头文件时，如果头文件中有定义语句，那么不管是什么东西的定义，都会产生重定义错误。</p></li></ul><p><strong>解决方法</strong></p><ul><li>针对情况一：我们应当避免在头文件中<strong>定义局部变量或者非内联函数</strong>。而由于编译器会将类，内联函数以及const变量默认视为定义它们的源文件所私有，因此它们（类，内联函数以及const变量）可以定义在头文件中。</li><li>针对情况二：使用ifndef或者pragma once</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ifndef和pragma once的区别</title>
    <link href="/2024/07/31/ifndef%E5%92%8Cpragma-once%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/31/ifndef%E5%92%8Cpragma-once%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="ifndef和pragma-once的区别"><a href="#ifndef和pragma-once的区别" class="headerlink" title="ifndef和pragma once的区别"></a>ifndef和pragma once的区别</h1><p><strong>1）#ifndef</strong></p><p> #ifndef的方式受C&#x2F;C++语言标准支持。它不仅可以保证<strong>同一个文件不会被包含多次</strong>，也能<strong>保证相同的代码段不会被重复包含</strong>（比如定义了相同的类）</p><p> 当然，<strong>缺点就是</strong></p><ul><li><p>如果不同头文件中的宏名（也就是ifndef后面的名字）不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷。</p></li><li><p>由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得<strong>编译时间相对较长</strong>，因此一些编译器逐渐开始支持#pragma once的方式。</p></li></ul><p><strong>2）#pragma once</strong></p><p> #pragma once 一般由编译器提供保证：<strong>同一个文件不会被包含多次</strong>。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。</p><p> <strong>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。</strong></p><p> <strong>好处</strong>：</p><ul><li>你<strong>不必再担心宏名冲突</strong>了，当然也就不会出现宏名冲突引发的奇怪问题。</li><li>大型项目的<strong>编译速度</strong>也因此提高了一些。</li></ul><p> 对应的<strong>缺点</strong></p><ul><li><p>如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种重复包含很容易被发现并修正。</p></li><li><p>不支持跨平台！</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt事件处理机制</title>
    <link href="/2024/07/31/Qt%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/31/Qt%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Qt事件处理机制"><a href="#Qt事件处理机制" class="headerlink" title="Qt事件处理机制"></a>Qt事件处理机制</h1><p><strong>事件</strong>：</p><ol><li>来源是系统中的中断，包括与Qt相关的中断（如硬件操作控制产生的中断）和程序中的定时器产生的中断</li><li>Qt程序中通过QEvent基类来表示各种类型的事件。</li></ol><p>QApplication对象负责监听整个应用程序中所有控件的事件。</p><p><strong>Qt事件处理器机制：</strong></p><p>​由exec执行的事件循环在监听整个应用程中所有事件，收到事件通知的控件通过过滤及分发函数，到达事件处理函数。</p><p><strong>事件与Qt信号槽的关系：</strong></p><ol><li>事件是信号槽中信号产生的基础，但两者不是一回事</li><li>事件解决本控件对应系统信号的响应问题，而信号槽则用于两个不相关控件之间的通信问题。</li></ol><h2 id="Qt底层维护的事件处理机制路径"><a href="#Qt底层维护的事件处理机制路径" class="headerlink" title="Qt底层维护的事件处理机制路径"></a>Qt底层维护的事件处理机制路径</h2><ul><li><strong>事件通知</strong>：QApplication中的bool notify(QObject* recver, QEvent* e)函数。</li><li><strong>事件过滤</strong>：eventFilter(QObject watched, QEvent* event)函数。</li><li><strong>事件分发</strong>：event(QEvent* e)函数。</li><li><strong>事件处理函数</strong>：受保护的虚函数。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt中的事件分发过程</title>
    <link href="/2024/07/31/Qt%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/07/31/Qt%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Qt中的事件分发过程"><a href="#Qt中的事件分发过程" class="headerlink" title="Qt中的事件分发过程"></a>Qt中的事件分发过程</h1><ol><li><p>当事件产生之后，Qt 使用应用程序对象<strong>调用 <code>notify()</code> 函数</strong>将事件发送到指定的窗口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-keyword">override</span> <span class="hljs-keyword">virtual</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QApplication::notify</span><span class="hljs-params">(QObject *receiver, QEvent *e)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>事件在发送过程中可以通过<strong>事件过滤器</strong>进行过滤，默认不对任何产生的事件进行过滤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-keyword">virtual</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QObject::eventFilter</span><span class="hljs-params">(QObject *watched, QEvent *event)</span></span><br></code></pre></td></tr></table></figure><p>需要先给窗口安装过滤器，该事件才会触发。</p></li><li><p>当事件发送到指定窗口之后，窗口的<strong>事件分发器</strong>会对收到的事件进行分类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-keyword">override</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QWidget::event</span><span class="hljs-params">(QEvent *event)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>事件分发器会将分类之后的事件（鼠标事件、键盘事件、绘图事件…）分发给对应的<strong>事件处理器函数</strong>进行处理，每个事件处理器函数都有默认的处理动作（我们也可以重写这些事件处理器函数），比如：鼠标事件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 鼠标按下</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br><br><span class="hljs-comment">// 鼠标释放</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br><br><span class="hljs-comment">// 鼠标移动</span><br>[<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">protected</span>] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QWidget::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>do ...while(false)</title>
    <link href="/2024/07/31/do-while-false/"/>
    <url>/2024/07/31/do-while-false/</url>
    
    <content type="html"><![CDATA[<p>do while(false)的作用：主要是为了<strong>能在这个代码块里面随时终止操作</strong>，比如<code>do...while(false)</code>块包含了文件的读取、数据的解码、JSON解析等操作，如果在任何一个环节出现问题（如文件打开失败、数据解码失败或JSON解析失败），代码会通过<code>break</code>语句跳出循环（正常是会在代码块里面返回），然后执行后面的清理或者默认操作。第二个作用是<strong>避免了在多个地方重复相同的清理代码</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程间传递文件套接字</title>
    <link href="/2024/07/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <url>/2024/07/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>unlink和close</title>
    <link href="/2024/07/31/unlink%E5%92%8Cclose/"/>
    <url>/2024/07/31/unlink%E5%92%8Cclose/</url>
    
    <content type="html"><![CDATA[<p><code>unlink</code>函数在这段代码中的作用是删除一个<strong>文件系统中的文件或者取消一个已命名的管道、套接字</strong>等。</p><p><code>unlink</code>操作成功后，如果还有其他进程已经打开了这个文件或套接字，它们仍然可以继续使用，直到它们也关闭了该文件描述符。</p><p>函数close是用来断开文件描述符和已打开文件之间的连接，并释放此文件描述符，以供其他文件使用。如果程序通过exit函数退出或者从主程序中返回，所有打开的文件将被关闭。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>函数unlink(char *name)将文件name从文件系统中删除，它对应于标准库函数remove。它会断开文件名与文件内容（inode）之间的链接。如果该文件没有其他硬链接且没有进程正在使用它，文件占用的存储空间会被回收。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>本地套接字与网络套接字的区别和用法</title>
    <link href="/2024/07/31/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/"/>
    <url>/2024/07/31/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>网络套接字</strong>是通过<strong>绑定ip和端口</strong>使网络中的进程之间进行通信，而<strong>本地套接字****是绑定套接字文件的路径名来使单机中的进程间通信</strong>,是一种IPC机制,其存储地址结构的数据类型为<code>struct sockaddr_un</code>,该数据类型包含在<code>#include&lt;sys/un.h&gt;</code>头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_un</span> &#123;<br><span class="hljs-type">sa_family_t</span> sun_family; <span class="hljs-comment">/*PF_UNIX或AF_UNIX */</span><br><span class="hljs-type">char</span> sun_path[UNIX_PATH_MAX]; <span class="hljs-comment">/* 路径名 */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>网络套接字客户端可以隐式绑定ip和端口，但是<strong>本地套接字客户端必须绑定套接字文件的路径名</strong>，否则无法通信(因为本地套接字通信模式中bind函数会创建套接字文件，两个进程之间的通信是通过各自的套接字文件来进行的)</p></li></ol><p>其他的跟网络套接字使用一样</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unix/Linux系统中的`fork()`系统调用</title>
    <link href="/2024/07/31/Unix-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2024/07/31/Unix-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>使用Unix&#x2F;Linux系统中的<code>fork()</code>系统调用时，需要注意的线程与进程之间的关系和潜在问题</p><ol><li><strong>线程无法被复制</strong>：<code>fork()</code>发生时，只有调用<code>fork()</code>的那个线程会被复制到子进程中，其他的线程不会被复制过去。</li><li><strong>破坏多线程模式</strong>：如果父进程中某个线程负责资源的初始化或清理，而在子进程中这个线程不存在，那么可能会导致资源未被正确管理，进而引发错误。</li><li><strong>先准备好进程结构，再去使用线程</strong>：涉及<code>fork()</code>和多线程的程序时，应该先明确进程的创建和初始化过程，确保在创建新的线程之前，进程的结构已经稳定。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于I/O 完成端口的多线程安全队列</title>
    <link href="/2024/07/26/%E5%9F%BA%E4%BA%8EI-O-%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/"/>
    <url>/2024/07/26/%E5%9F%BA%E4%BA%8EI-O-%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IOCP异步编程</title>
    <link href="/2024/07/26/IOCP%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/07/26/IOCP%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="iocp异步编程流程"><a href="#iocp异步编程流程" class="headerlink" title="iocp异步编程流程"></a>iocp异步编程流程</h1><ol><li><p><strong>创建I&#x2F;O完成端口</strong>: 使用<code>CreateIoCompletionPort</code>函数创建一个I&#x2F;O完成端口。这个端口将作为异步操作完成时的通知中心，需要与套接字关联。</p><blockquote><p><code>HANDLE CreateIoCompletionPort(  HANDLE FileHandle,  HANDLE ExistingCompletionPort,  ULONG_PTR CompletionKey,  DWORD NumberOfConcurrentThreads );</code></p><ol><li><strong>FileHandle</strong>：要与新创建或已存在的I&#x2F;O完成端口关联的文件句柄。首次创建IOCP传入<code>INVALID_HANDLE_VALUE</code>，表示仅创建一个空的I&#x2F;O完成端口。</li><li><strong>ExistingCompletionPort</strong>：一个已存在的I&#x2F;O完成端口句柄。如果想将<code>FileHandle</code>关联到这个已存在的I&#x2F;O完成端口上，就提供这个句柄；如果是要创建一个新的I&#x2F;O完成端口，则此参数应为<code>NULL</code>。</li><li><strong>CompletionKey</strong>：一个无符号长整数，由应用程序提供，作为完成键（Completion Key）。当一个I&#x2F;O操作完成时，这个键会随着完成通知一起返回给应用程序，用于标识完成的I&#x2F;O操作或与之关联的上下文。</li><li><strong>NumberOfConcurrentThreads</strong>：指定工作线程池中可以同时运行的线程的最大数目。如果设置为0，则系统将自动调整线程数量以达到最佳性能。通常，合理的线程数取决于系统的CPU核心数和I&#x2F;O负载。</li></ol><p>具体：<code>m_HIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 4);</code></p><ul><li>成功时，返回新创建或已关联的I&#x2F;O完成端口的句柄。</li><li>失败时，返回<code>NULL</code>，并可通过<code>GetLastError</code>获取错误码。</li></ul></blockquote></li><li><p><strong>创建并配置套接字</strong>: 使用<code>WSASocket</code>函数创建一个或多个套接字，并设置为使用重叠I&#x2F;O模型（通过<code>WSA_FLAG_OVERLAPPED</code>标志），允许套接字进行异步操作。</p><blockquote><p>具体：<code>m_servSocket = WSASocket(PF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);</code></p><ul><li><strong>af</strong>：地址族，如<code>AF_INET</code>用于IPv4或<code>AF_INET6</code>用于IPv6。</li><li><strong>type</strong>：套接字类型，如<code>SOCK_STREAM</code>用于TCP连接，<code>SOCK_DGRAM</code>用于UDP数据报。</li><li><strong>protocol</strong>：指定协议，通常为0，让系统根据<code>af</code>和<code>type</code>自动选择。</li><li><strong>lpProtocolInfo</strong>：指向一个<code>WSAPROTOCOL_INFO</code>结构的指针，允许直接指定协议信息，提供更细粒度的控制。</li><li><strong>g</strong>：保留，通常传入0。</li><li><strong>dwFlags</strong>：标志位，如<code>WSA_FLAG_OVERLAPPED</code>表示创建支持重叠I&#x2F;O的套接字，这对于使用IOCP模型是必需的。</li></ul></blockquote></li><li><p><strong>绑定套接字到I&#x2F;O完成端口</strong>: 再次使用<code>CreateIoCompletionPort</code>函数将每个套接字与之前创建的I&#x2F;O完成端口关联。这一步确保与这些套接字相关的I&#x2F;O操作完成时，通知将被发送到I&#x2F;O完成端口。</p><blockquote><p>具体：<code>CreateIoCompletionPort((HANDLE)m_servSocket, m_HIOCP, 0, 0)</code></p><ul><li><strong>m_servSocket</strong>：要关联的套接字；</li><li><strong>m_HIOCP</strong>：创建的完成端口</li></ul></blockquote></li><li><p><strong>初始化OVERLAPPED结构</strong>: 对于每个异步操作（如<code>ConnectEx</code>, <code>ReadFile</code>, <code>WriteFile</code>, <code>WSARecv</code>, <code>WSASend</code>等），都需要创建并初始化一个或多个<code>OVERLAPPED</code>结构（或其派生类），这个结构包含了操作的状态信息和完成时的回调参数。这里除了原始的OVERLAPPED，还包括连接的其他重要参数信息</p><blockquote><p><code>CMClient* pClient = new CMClient(this,m_HIOCP);</code></p></blockquote></li><li><p><strong>启动监听或连接操作</strong>: 根据需要，使用如<code>bind</code>, <code>listen</code>, <code>AcceptEx</code>等函数开始监听网络连接。对于客户端，可能直接使用<code>ConnectEx</code>进行异步连接。</p><blockquote><pre><code class="hljs">            AcceptEx(m_servSocket, pClient-&gt;m_clntSocket,                pClient-&gt;m_accept-&gt;m_buffer.data(),0,                sizeof(sockaddr_in) + 16,sizeof(sockaddr_in) + 16,                &amp;pClient-&gt;m_accept-&gt;m_received,&amp;pClient-&gt;m_accept-&gt;m_overlapped);</code></pre></blockquote></li><li><p><strong>发起异步I&#x2F;O操作</strong>: 当准备读取或写入数据时，使用相应的异步函数，如<code>WSARecv</code>和<code>WSASend</code>，并将之前准备好的<code>OVERLAPPED</code>结构传递给这些函数。<strong>这些操作会立即返回，而不会等待I&#x2F;O完成</strong>。</p></li><li><p><strong>等待并处理I&#x2F;O完成通知</strong>: 在主线程或一个专用的工作线程中，使用<code>GetQueuedCompletionStatus</code>循环等待I&#x2F;O完成的通知。当一个I&#x2F;O操作完成时，这些函数会返回，并提供完成键、传输的字节数、以及指向关联的<code>OVERLAPPED</code>结构的指针。</p><blockquote><p>取出<code>OVERLAPPED</code>结构的指针进行下一步的处理，这里可以把指针转换为一个结构体，涉及到类的下行转换，虽然说理论上是不安全的，但是这里也没有使用dynamic_cast进行强制类型转换，因为传进去的时候其实就是一个派生类的m_overlapped成员变量，自己知道这个下行转换是安全的</p></blockquote></li><li><p><strong>根据完成键和OVERLAPPED结构处理操作结果</strong>: 根据<code>OVERLAPPED</code>结构中的信息，确定操作类型（如读、写、接受连接等）并执行相应的后续处理。这可能包括数据处理、错误处理、再次发起读写操作等。然后就循环新连接，接受发送，然后等待异步处理</p></li></ol><p><strong>这里要注意的是如果是处理了一个新连接的时候要重新创建一个客户端socket然后与io完成端口绑定，才能接受新的连接</strong></p><h1 id="AcceptEx函数以及与accept函数的区别"><a href="#AcceptEx函数以及与accept函数的区别" class="headerlink" title="AcceptEx函数以及与accept函数的区别"></a>AcceptEx函数以及与accept函数的区别</h1><p><code>AcceptEx</code>函数是Winsock2 扩展API的一部分，专用于Windows平台，用于异步接受TCP连接请求。它相比传统的<code>accept</code>函数提供了更多的功能和灵活性。</p><h2 id="AcceptEx-函数介绍"><a href="#AcceptEx-函数介绍" class="headerlink" title="AcceptEx 函数介绍"></a>AcceptEx 函数介绍</h2><ul><li><strong>功能</strong>：<code>AcceptEx</code>函数允许服务器端在同一个调用中完成接受连接请求和接收连接套接字的<strong>初始化工作</strong>，同时还能<strong>从连接请求中提取客户端地址信息</strong>。它支持重叠I&#x2F;O模型，因此可以与I&#x2F;O完成端口（IOCP）结合，实现高效的异步接受处理。</li><li><strong>参数</strong>：<code>AcceptEx</code>接受多个参数，包括监听套接字、新的接受套接字（预先创建）、用于存储连接数据的缓冲区、缓冲区偏移量以及指向接收缓冲区大小和接收的地址信息的指针。它还接受一个<code>OVERLAPPED</code>结构的指针，用于异步操作的完成通知。</li><li><strong>缓冲区共享</strong>：<code>AcceptEx</code>使用一个共享的缓冲区来<strong>同时接收连接请求数据和客户端地址信息</strong>，这有助于减少系统调用和内存分配，提高效率。</li></ul><h2 id="与accept的区别"><a href="#与accept的区别" class="headerlink" title="与accept的区别"></a>与accept的区别</h2><ol><li><strong>异步支持</strong>：<code>accept</code>函数在默认情况下是<strong>阻塞</strong>的，即调用它时，如果没有新的连接请求到达，调用线程会被阻塞，直到连接请求到来。而<code>AcceptEx</code>设计用于异步操作，结合重叠I&#x2F;O和I&#x2F;O完成端口，可以避免阻塞，提高服务器的响应性和处理能力。</li><li><strong>连接初始化</strong>：<code>accept</code>函数接受连接后会返回一个新的套接字，而这个新套接字需要进一步的配置，如设置为非阻塞模式、绑定、设置选项等。<code>AcceptEx</code>则允许在函数调用时直接指定并初始化这个新套接字，减少了额外的配置步骤。</li><li><strong>数据接收</strong>：<code>AcceptEx</code>在接受连接的同时，可以读取连接请求的初始数据，<code>accept</code>不能。</li><li><strong>缓冲区管理</strong>：如前所述，<code>AcceptEx</code>使用共享缓冲区来存储连接数据和地址信息，而<code>accept</code>不涉及缓冲区管理，只负责接受连接。</li><li><strong>平台特定</strong>：<code>AcceptEx</code>是Windows特有的，而<code>accept</code>则是POSIX标准的一部分，跨平台兼容性更好。</li></ol><h1 id="设置重叠io的技巧"><a href="#设置重叠io的技巧" class="headerlink" title="设置重叠io的技巧"></a>设置重叠io的技巧</h1><p>​重叠io是关联了一个客户端连接的，具体的可以关联到一个客户端的某个操作，包括发送、接受、创建和关闭，也就是说重叠io是跟某一个客户端关联的，所以我们可以在重叠io这里设置了一个类，类里面的第一个成员变量是重叠io，后面的成员变量客户端连接的状态信息，包括客户端连接的上下文信息，I&#x2F;O操作类型，实际接受到的字节数，数据缓冲区这些信息。这样的话，在收到完成端口传出来的重叠io的时候就可以进行类型转换，然后得到这个客户端连接的状态信息。</p><p>​对于不同操作对应的重叠io，可以把它设置为一个重叠io的派生类，包括发送，接受，创建，关闭这四个派生类，派生类里面的关键是一个回调函数，每个操作都会有一个回调函数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池类设计</title>
    <link href="/2024/07/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/07/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>1 <strong>首先要先封装线程类</strong>。线程的创建、销毁、设置、启动、停止和主线程函数都要设置好接口。</p><p>2 <strong>然后设计线程池类</strong>。需要设计好接口：初始化、大小调整、添加任务、关闭、获取尺寸、启动等。线程池有一个任务列表属性，一个事件属性和一个互斥锁。外部投递进来的任务先是加入任务列表属性。然后设置事件属性。每个子线程都会等待事件。一旦事件被设置，则获取到该事件的线程就会通过互斥锁来同步任务列表，取其中一个任务出来开始执行。</p><p>3 <strong>设计任务类</strong>。任务类需要有一个任务函数接口。这个接口线程类会自动调用。此外需要封装一些做参数用的属性。一般任务类是基类，用户可以依据自己的需求去派生子类。子类重载任务函数即可，也可以自己追加一些属性，用于任务函数。</p><p>4 <strong>最后整合三个模块</strong>，一个最原始的线程池就完成了。</p><h1 id="任务类："><a href="#任务类：" class="headerlink" title="任务类："></a>任务类：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMFuncBase</span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(CMFuncBase::* MT_FUNC)</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMWork</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>CMFuncBase* thiz;<br>MT_FUNC     func;<br><span class="hljs-built_in">CMWork</span>(CMFuncBase* objThis, MT_FUNC objFunc)<br>&#123;<br>thiz= objThis;<br>func= objFunc;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (thiz-&gt;*func)();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMThread</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>std::atomic&lt;CMWork*&gt; m_work;<br>HANDLE               m_thread;<br>HANDLE m_event;<br><span class="hljs-type">bool</span> m_run;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadEntry</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>CMThread* thiz = (CMThread*)arg;<br>thiz-&gt;<span class="hljs-built_in">ThreadMain</span>();<br>_endthread();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadMain</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (m_run)<br>&#123;<br><span class="hljs-built_in">WaitForSingleObject</span>(m_event, INFINITE);<br><br><span class="hljs-type">int</span> ret = (*m_work)();<br><span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_work;<br>m_work = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">Notify</span>(<span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CMThread</span>()<br>&#123;<br>m_work = <span class="hljs-literal">NULL</span>;<br>m_thread = INVALID_HANDLE_VALUE;<br>m_event = <span class="hljs-built_in">CreateEvent</span>(<span class="hljs-literal">NULL</span>, FALSE, FALSE, <span class="hljs-literal">NULL</span>);<br>m_run = <span class="hljs-literal">true</span>;<br>&#125;<br>~<span class="hljs-built_in">CMThread</span>()<br>&#123;<br><span class="hljs-built_in">Stop</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(<span class="hljs-type">bool</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (b)<br>&#123;<br><span class="hljs-built_in">SetEvent</span>(m_event);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">ResetEvent</span>(m_event);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Work</span><span class="hljs-params">(<span class="hljs-type">const</span> CMWork&amp; work)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_work != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_work;<br>&#125;<br>m_work = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CMWork</span>(work);<br><span class="hljs-built_in">Notify</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_thread = (HANDLE)_beginthread(&amp;CMThread::ThreadEntry, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span> (m_thread == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程启动失败\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_run == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>m_run = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">WaitForSingleObject</span>(m_thread, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stop ret : %d\r\n&quot;</span>, ret);<br><span class="hljs-keyword">if</span> (ret == WAIT_OBJECT_0)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFree</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_run &amp;&amp; (m_work == <span class="hljs-literal">NULL</span>))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="线程池类"><a href="#线程池类" class="headerlink" title="线程池类"></a>线程池类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMThreadPool</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>std::vector&lt;CMThread*&gt;m_vecThreads;<br>std::mutexm_mutex;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CMThreadPool</span>(<span class="hljs-type">int</span> count)<br>&#123;<br>m_mutex.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br>m_vecThreads.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CMThread</span>());<br>&#125;<br>m_mutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br>~<span class="hljs-built_in">CMThreadPool</span>()<br>&#123;<br><span class="hljs-built_in">Stop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">delete</span> m_vecThreads.<span class="hljs-built_in">at</span>(i);<br>&#125;<br>m_mutex.<span class="hljs-built_in">lock</span>();<br>m_vecThreads.<span class="hljs-built_in">clear</span>();<br>m_mutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Invoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> isOk = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">Start</span>())<br>&#123;<br>isOk = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (isOk)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">Stop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> isOk = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">Stop</span>())<br>&#123;<br>isOk = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (isOk == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程关闭失败&quot;</span>);<br>&#125;<br><span class="hljs-comment">//assert(isOk);</span><br><span class="hljs-keyword">return</span> isOk;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispatchWork</span><span class="hljs-params">(<span class="hljs-type">const</span> CMWork&amp; work)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_vecThreads.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">IsFree</span>())<br>&#123;<br>m_vecThreads.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">Work</span>(work);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>线程池测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>va_list的用法</title>
    <link href="/2024/07/21/va-list%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2024/07/21/va-list%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="VA-LIST的用法："><a href="#VA-LIST的用法：" class="headerlink" title="VA_LIST的用法："></a>VA_LIST的用法：</h1><ol><li><p>首先在函数里定义一具VA_LIST型的变量，这个变量是指向参数的指针； </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">va_list args<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>然后用VA_START宏初始化变量刚定义的VA_LIST变量； </p><p>使用<code>va_start</code>宏初始化<code>va_list</code>变量。<code>va_start</code>需要两个参数：<code>va_list</code>变量和最后一个固定参数（在…之前的参数）的地址。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">void my_printf(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">format</span>, ...) &#123;<br>    va_list <span class="hljs-keyword">args</span>;<br>    va_start(<span class="hljs-keyword">args</span>, <span class="hljs-keyword">format</span>); <span class="hljs-comment">// 注意：format是位于...之前的最后一个已知参数</span><br>    <span class="hljs-comment">// 接下来可以使用args访问可变参数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后用VA_ARG返回可变的参数，VA_ARG的第二个参数是你要返回的参数的类型（如果函数有多个可变参数的，依次调用VA_ARG获取各个参数）；</p><p><code>va_arg</code>需要两个参数：第一个是<code>va_list</code>变量，第二个是要获取的参数类型。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> arg_int = va_arg(args, <span class="hljs-keyword">int</span>); <span class="hljs-regexp">//</span> 获取一个<span class="hljs-keyword">int</span>类型的参数<br></code></pre></td></tr></table></figure></li><li><p>最后用VA_END宏结束可变参数的获取，清理操作，通常放在函数的末尾。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">va_end</span>(args);<br></code></pre></td></tr></table></figure></li></ol><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino">LogInfo::<span class="hljs-built_in">LogInfo</span>(<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">int</span> line, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* func,<br><span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">int</span> level,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...<br>)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> sLevel[][<span class="hljs-number">8</span>] = &#123;<br><span class="hljs-string">&quot;INFO&quot;</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>,<span class="hljs-string">&quot;WARNING&quot;</span>,<span class="hljs-string">&quot;ERROR&quot;</span>,<span class="hljs-string">&quot;FATAL&quot;</span><br>&#125;;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">NULL</span>;<br>bAuto = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//日志前缀</span><br><span class="hljs-type">int</span> count = <span class="hljs-built_in">asprintf</span>(&amp;buf, <span class="hljs-string">&quot;%s(%d):[%s][%s]&lt;%d-%d&gt;(%s) &quot;</span>,<br>file, line, sLevel[level],<br>(<span class="hljs-type">char</span>*)CLoggerServer::<span class="hljs-built_in">GetTimeStr</span>(), pid, tid, func);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf = buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//日志变参部分</span><br>va_list ap;<br><span class="hljs-built_in">va_start</span>(ap, fmt);<br>count = <span class="hljs-built_in">vasprintf</span>(&amp;buf, fmt, ap);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>m_buf += buf;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br><span class="hljs-built_in">va_end</span>(ap);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="额外知识："><a href="#额外知识：" class="headerlink" title="额外知识："></a>额外知识：</h2><p><code>vasprintf</code>是一个高级的变体，它结合了<code>vprintf</code>的功能（使用<code>va_list</code>参数列表格式化输出）和<code>asprintf</code>的能力（自动分配所需的缓冲区来存放结果字符串）。</p><p><code>asprintf</code>和<code>vsprintf</code>都是C语言中用于格式化输出字符串到动态分配的内存或预定义缓冲区的函数，它们都是<code>printf</code>系列函数的变体，主要用于处理可变参数列表。</p><h3 id="vsprintf"><a href="#vsprintf" class="headerlink" title="vsprintf"></a>vsprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, va_list arg)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>:</p><p><code>vsprintf</code>函数将<code>format</code>字符串中指定的格式化字符串写入到由<code>str</code>指向的缓冲区中。与<code>sprintf</code>类似，但它不是直接接受可变参数，而是通过一个<code>va_list</code>（由<code>va_start</code>初始化）来访问参数列表。</p><p><strong>参数</strong>:</p><ul><li><code>str</code>: 目标缓冲区的指针，必须足够大以容纳格式化后的字符串，否则会导致缓冲区溢出。</li><li><code>format</code>: 控制定制字符串格式的格式字符串，由普通文本和特殊的格式占位符组成，这些占位符指示如何处理并插入相应的参数值</li><li><code>arg</code>: 一个之前由<code>va_start</code>初始化的<code>va_list</code>，用于访问可变参数列表。</li></ul><h3 id="asprintf"><a href="#asprintf" class="headerlink" title="asprintf"></a>asprintf</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">asprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> **strp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>: <code>asprintf</code>函数类似于<code>vsprintf</code>，但更加方便和安全，因为它会自动为格式化后的字符串分配内存，并通过<code>strp</code>返回指向这块内存的指针，<strong>调用者无需预先分配或担心缓冲区溢出问题</strong>。</p><p><strong>特点</strong>:</p><ul><li><code>asprintf</code>自动管理内存分配，改变指针指向</li><li>第三个参数是可变参数，而不是预先初始化好的可变参数列表va_list。</li></ul><p><strong>注意事项</strong>:</p><ul><li>动态分配的内存需要通过<code>free</code>手动释放，以防止内存泄漏。</li></ul><h3 id="vasprintf"><a href="#vasprintf" class="headerlink" title="vasprintf"></a>vasprintf</h3><p><code>vasprintf</code>会根据<code>fmt</code>和<code>ap</code>中的参数<strong>自动格式化字符串</strong>，并动态分配内存给结果字符串，然后修改了传入的<code>buf</code>（一个指针）的值，使其指向新分配的、包含格式化后字符串的内存区域，之后可以直接通过<code>buf</code>访问到这个新创建的字符串</p>]]></content>
    
    
    
    <tags>
      
      <tag>语言技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
